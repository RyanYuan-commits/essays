### 1 四次挥手
#### 1.1 四次挥手过程
双方都可以主动断开连接，断开连接后主机中的「资源」将被释放，四次挥手的过程如下图：
![[四次挥手过程.png|500]]
- 客户端打算关闭连接，此时会发送一个 `FIN` 报文，之后客户端进入 `FIN_WAIT_1` 状态。
- 服务端收到该报文后，就向客户端发送 `ACK` 应答报文，接着服务端进入 `CLOSE_WAIT` 状态。
- 客户端收到服务端的 `ACK` 应答报文后，之后进入 `FIN_WAIT_2` 状态。
- 等待服务端处理完数据后，也向客户端发送 `FIN` 报文，之后服务端进入 `LAST_ACK` 状态。
- 客户端收到服务端的 `FIN` 报文后，回一个 `ACK` 应答报文，之后进入 `TIME_WAIT` 状态
- 服务端收到了 `ACK` 应答报文后，就进入了 `CLOSE` 状态，至此服务端已经完成连接的关闭。
- 客户端在经过 `2MSL` 一段时间后，自动进入 `CLOSE` 状态，至此客户端也完成连接的关闭。
每个方向都需要一个 FIN 和一个 ACK，因此通常被称为**四次挥手**；这里一点需要注意是：主动关闭连接的，才有 TIME_WAIT 状态。
#### 1.2 为什么需要四次挥手？
再来回顾下四次挥手双方发 `FIN` 包的过程，就能理解为什么需要四次了。
- 关闭连接时，客户端向服务端发送 `FIN` 时，仅仅表示客户端不再发送数据了但是还能接收数据。
- 服务端收到客户端的 `FIN` 报文时，先回一个 `ACK` 应答报文，而服务端可能还有数据需要处理和发送，等服务端不再发送数据时，才发送 `FIN` 报文给客户端来表示同意现在关闭连接。
从上面过程可知，服务端通常需要等待完成数据的发送和处理，所以服务端的 `ACK` 和 `FIN` 一般都会分开发送，因此是需要四次挥手。
#### 1.3 TIME_WAIT 状态
MSL（Maximum Segment Lifetime），报文最大生存时间，它是任何报文在网络上存在的最长时间，超过这个时间报文将被丢弃。
`TIME_WAIT` 会持续 2MSL，比较合理的解释是：网络中可能存在来自发送方的数据包，当这些发送方的数据包被接收方处理后又会向对方发送响应，所以一来一回需要等待 2 倍的时间，同时，这个时间是从客户端接收到 FIN 后发送 ACK 开始计时的，如果在 `TIME-WAIT` 时间内，因为客户端的 ACK 没有传输到服务端，客户端又接收到了服务端重发的 FIN 报文，那么 2MSL 时间将重新计时，这就保证「被动关闭连接」的一方，能被正确的关闭。
同时，它还可以防止历史连接中的数据被错误接收，序列号和初始化序列号并不是无限递增的，会发生回绕为初始值的情况，这意味着无法根据序列号来判断新老数据TCP 设计了 `TIME_WAIT` 状态，状态会持续 2MSL 时长，这个时间足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。
### 2 报文丢失问题
#### 2.1 第一次挥手丢失
当客户端（主动关闭方）调用 close 函数后，就会向服务端发送 FIN 报文，试图与服务端断开连接，此时客户端的连接进入到 `FIN_WAIT_1` 状态。
正常情况下，如果能及时收到服务端（被动关闭方）的 ACK，则会很快变为 `FIN_WAIT2`状态。
如果第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK 的话，也就会触发超时重传机制，重传 FIN 报文，重发次数由 `tcp_orphan_retries` 参数控制。
当客户端重传 FIN 报文的次数超过 `tcp_orphan_retries` 后，就不再发送 FIN 报文，则会在等待一段时间（时间为上一次超时时间的 2 倍），如果还是没能收到第二次挥手，那么直接进入到 `close` 状态。
#### 2.2 第二次挥手丢失
当服务端收到客户端的第一次挥手后，就会先回一个 ACK 确认报文，此时服务端的连接进入到 `CLOSE_WAIT` 状态；
主动关闭方会因为没有收到 ACK 报文而重复发送 FIN 报文，如果迟迟没有收到 ACK，客户端会根据关闭方式选择不同的处理机制：
- shutdown 方式，这种方式只会关闭本方的发送功能，而仍然可以接收数据，此时如果没有收到第二次挥手，那么主动关闭方的连接将会一直处于 `FIN_WAIT2` 状态（`tcp_fin_timeout` 无法控制 `shutdown` 关闭的连接）。
- close 方式，发送和接收功能都会关闭；所以`FIN_WAIT2` 状态不可以持续太久，而 `tcp_fin_timeout` 控制了这个状态下连接的持续时长，默认值是 60 秒。如果在 60 秒后还没有收到 FIN 报文，客户端（主动关闭方）的连接就会直接关闭。
#### 2.3 第三次挥手丢失
当服务端（被动关闭方）收到客户端（主动关闭方）的 FIN 报文后，内核会自动回复 ACK，同时连接处于 `CLOSE_WAIT` 状态，顾名思义，它表示等待应用进程调用 close 函数关闭连接。
此时，内核是没有权利替代进程关闭连接，必须由进程主动调用 close 函数来触发服务端发送 FIN 报文。
服务端处于 CLOSE_WAIT 状态时，调用了 close 函数，内核就会发出 FIN 报文，同时连接进入 LAST_ACK 状态，等待客户端返回 ACK 来确认连接关闭。
如果迟迟收不到这个 ACK，服务端就会重发 FIN 报文，重发次数仍然由 `tcp_orphan_retries` 参数控制，这与客户端重发 FIN 报文的重传次数控制方式是一样的。
#### 2.4 第四次挥手丢失
当客户端收到服务端的第三次挥手的 `FIN` 报文后，就会回 `ACK` 报文，也就是第四次挥手，此时客户端连接进入 `TIME_WAIT` 状态。
如果第四次挥手的 ACK 报文没有到达服务端，服务端就会重发 FIN 报文，重发次数仍然由前面介绍过的 `tcp_orphan_retries` 参数控制。
- 当服务端重传第三次挥手报文达到 2 时，由于 `tcp_orphan_retries` 为 2， 达到了最大重传次数，于是再等待一段时间（时间为上一次超时时间的 2 倍）；
  如果还是没能收到客户端的第四次挥手（ACK 报文），那么服务端就会断开连接。
- 客户端在收到第三次挥手后，就会进入 `TIME_WAIT` 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（`FIN` 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接。
什么是粘包和半包？先从数据包的发送和接收开始讲起。大家知道，Netty 发送和读取数据的“场所”是 ByteBuf 缓冲区。对于发送端，每一次发送就是向通道写入一个 ByteBuf，发送数据时先填好 ByteBuf，然后通过通道发送出去。对于接收端，每一次读取就是通过 Handler 业务处理器的入站方法，
从通道读到一个 ByteBuf。
读取数据的方法如下：
```java
public void channelRead(ChannelHandlerContext ctx, Object msg) {
	ByteBufbyteBuf = (ByteBuf) msg;
	//....省略入站处理
}
```
最为理想的情况是：发送端每发送一个 ByteBuf 缓冲区，接收端就能接收到一个 ByteBuf，并且发送端和接收端的 ByteBuf 内容能一模一样。然后，理想很丰满，现实很骨感，现实总是那么残酷。在实际的通信过程中，并没有大家预料的那么完美。下面给大家看一个实例，看看实际通信过程中所遇到的诡异情况。
### 半包问题的实践案例
>[!info] 服务端 Handler 接收、打印消息并回显
```java
public class EchoHandler extends ChannelInboundHandlerAdapter {  
    @Override  
    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {  
        ByteBuf in = (ByteBuf) msg;  
        byte[] bytes = new byte[in.readableBytes()];  
        in.getBytes(0, bytes);  
        CharBuffer decode = StandardCharsets.UTF_8.decode(ByteBuffer.wrap(bytes));  
        System.out.println("收到消息：" + decode);  
        ctx.writeAndFlush(decode.toString());  
        in.release();  
    }  
}
```

>[!info] 客户端：向服务器发送 1000 个消息
```java
public class NettyClient {  
    public static void main(String[] args) throws InterruptedException {  
        Bootstrap bootstrap = new Bootstrap();  
        bootstrap.channel(NioSocketChannel.class);  
        bootstrap.group(new NioEventLoopGroup());  
        bootstrap.handler(new ChannelInitializer<Channel>() {  
            @Override  
            protected void initChannel(Channel ch) throws Exception {  
                System.out.println("init");  
            }  
        });  
        ChannelFuture connect = bootstrap.connect(new InetSocketAddress("127.0.0.1", 8080));  
  
        String content = "你好服务器，这里是客户端";  
        byte[] bytes = content.getBytes(StandardCharsets.UTF_8);  
  
        connect.sync();  
        Channel channel = connect.channel();  
        for (int i = 0; i < 1000; i++) {  
            ByteBuf buffer = channel.alloc().buffer();  
            buffer.writeBytes(bytes);  
            channel.writeAndFlush(buffer);  
        }  
    }  
}
```

最终服务端控制台打印的结果是这样的：
![[半包问题示例.png]]
仔细观察服务端的控制台输出，可以看出存在三种类型的输出：
	（1）读到一个完整的客户端输入ByteBuf；
	（2）读到多个客户端的ByteBuf输入，但是“粘”在了一起；
	（3）读到部分ByteBuf的内容，并且有乱码。
对应于第 1 种情况接收到的完整的 ByteBuf，这里称为“全包”。对应于第 2 种情况，多个发送端的输入 ByteBuf “粘”在了一起，这里称为“粘包”。对应于第 3 种情况，一个发送过来的 ByteBuf 被“拆开”接收，接收端读取到一个破碎的包，这里称为“半包”。
为了简单起见，也可以将 “粘包” 的情况看成特殊的 “半包”。“粘包” 和 “半包” 可以统称为传输的 “半包问题”。
### 什么是半包问题
半包问题包含了“粘包”和“半包”两种情况：
（1）粘包，指接收端收到一个 ByteBuf，包含了 Sender（发送端）的多个 ByteBuf，发送端的多个 ByteBuf 在接收端“粘”在了一起。
（2）半包，就是接收端将发送端的一个 ByteBuf “拆”开了收，收到多个破碎的包。换句话说，Receiver收到了Sender的一个ByteBuf的一小部分。
#### 半包问题的根因分析
粘包和半包的来源，得从操作系统底层说起。
底层网络是以二进制字节报文的形式来传输数据的，并且数据在进入传输阶段之前，还会发生 CPU 数据复制和 DMA 数据复制。无论在数据传输阶段，还是在数据复制阶段，都可能存在二进制字节数据的二次分隔。
写数据的过程大致为：
	编码器将一个 Java 类型的数据转换成底层能够传输的二进制 ByteBuf 缓冲数据。
	发送端的应用层 Netty 程序以 ByteBuf 为单位来发送数据，这些数据首先会通过 CPU 复制的方式，复制到了底层操作系统内核缓冲区；然后通过 DMA 复制的方式，复制到网卡设备，==这个 DMA 复制过程，会发生二进制数据的二次分隔==；
	数据被复制到网卡设备之后，网卡设备协议栈处理程序会按照 TCP/IP 协议规范对数据包进行二次封装，==封装成传输层TCP层的协议报文之后再进行发送，在这个数据包封装的过程中，也会发生二进制数据的二次分隔==。
**为什么在数据复制阶段，存在二进制字节数据的二次分隔呢？**
发送端在 DMA 复制阶段，DMA 设备会把内核缓冲区（Socket 发送缓冲区）中的数据复制到网卡设备中，当 TCP 内核缓冲区的单个数据包，可能比较小，一次 DMA 复制的会却不止一个内核缓冲区中的小包，会将多个小数据包一块复制，以便提升效率。这就是数据复制阶段的二进制字节数据的二次分隔。这种数据包的二次分隔操作操作，可能导致复制到网卡设备的数据包，出现粘包现象或者半包现象。
**为什么在数据传输阶段，存在二进制字节数据的二次分隔呢？**
一个 TCP 协议报文的有效数据（净菏数据）大小是有限制的，这个报文有效数据的大小被称之为 MSS，具体的 MSS 值会在三次握手阶段会进行协商，但是最大不会超过 1460 个字节。
正由于一个 TCP 数据包MSS值最大为 1460，==协议处理程序会最大限度的利用一个报文的空间==。
	如果原始的 ByteBuf 太小，协议处理程序会合并多个 ByteBuf 的二进制数据进行发送；
	反过来，如果原始的ByteBuf太大，协议处理程序会将 ByteBuf 的二进制数据分成多个二进制数据包，进行发送。
这就是在数据传输阶段二进制字节数据的二次分隔，这种传输阶段的二次分隔操作，可能导致接收端接所收到的数据包，出现粘包现象或者半包现象。
**如何解决呢？**
基本思路是，在接收端，Netty 程序需要根据自定义协议，将读取到的进程缓冲区 ByteBuf，在应用层进行==二次组装==，重新组装我们应用层的数据包。
接收端的这个过程通常也称为分包，或者叫做拆包。在Netty中分包的方法，主要有两种方法：
	（1）可以自定义解码器分包器：基于 ByteToMessageDecoder 或者 ReplayingDecoder，定义自己的用户缓冲区分包器。
	（2）使用Netty内置的解码器。如可以使用 Netty 内置的 LengthFieldBasedFrameDecoder 自定义长度数据包解码器，对用户缓冲区ByteBuf进行正确的分包。

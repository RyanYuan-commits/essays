# 涉及题目
No.1314 「[矩阵区域和](https://leetcode.cn/problems/matrix-block-sum/description/)」
No.724 「[矩阵区域和](https://leetcode.cn/problems/matrix-block-sum/)」
No.1352 「[最后 K 个数的乘积](https://leetcode.cn/problems/product-of-the-last-k-numbers/)」 
# 前缀和
## 矩阵区域和
给你一个 `m x n` 的矩阵 `mat` 和一个整数 `k` ，请你返回一个矩阵 `answer` ，其中每个 `answer[i][j]` 是所有满足下述条件的元素 `mat[r][c]` 的和： 
- `i - k <= r <= i + k,`
- `j - k <= c <= j + k` 且
- `(r, c)` 在矩阵内。
---
本题就是力扣第 304 题「[二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)」的翻版，可以直接复用这道题目的 `NumMatrix` 类。
![[矩阵区域和示例图.png|600]]
本题需要注意一下两个对角的位置和越界的情况。
```java
class Solution {
    int[][] prefix;
    public int[][] matrixBlockSum(int[][] mat, int k) {
        init(mat);
        int m = mat.length;
        int n = mat[0].length;
        int[][] res = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
	            // 计算两个角的坐标，防止越界
                int r1 = Math.max(i - k, 0);
                int c1 = Math.max(j - k, 0);
                int r2 = Math.min(i + k, m - 1);
                int c2 = Math.min(j + k, n - 1);
                res[i][j] = cal(r1, c1, r2, c2);
            }
        }
        return res;
    }
    void init(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        prefix = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] - 
                                    prefix[i - 1][j - 1] + mat[i - 1][j - 1];
            }
        }
    }
    int cal(int r1, int c1, int r2, int c2) {
        return prefix[r2 + 1][c2 + 1] - prefix[r2 + 1][c1] - prefix[r1][c2 + 1] + prefix[r1][c1];
    }
}
```
## 寻找数组的中心下标
给你一个整数数组 `nums` ，请计算数组的 **中心下标** 。
数组 **中心下标** 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。
- 如果中心下标位于数组最左端，那么左侧数之和视为 `0` ，因为在下标的左侧不存在元素。
- 这一点对于中心下标位于数组最右端同样适用。如果数组有多个中心下标，应该返回 **最靠近左边** 的那一个。如果数组不存在中心下标，返回 `-1` 。
---
翻译过来也就是 `prefix[i - 1] == sum - prefix[i]`，还需要注意一下 i 为 0 的情况，此时必须要 `sum - nums[0] == 0`。
```java
class Solution {
    public int pivotIndex(int[] nums) {
        int sum = 0;
        int len = nums.length;
        int[] prefix = new int[len];
        for (int i = 0; i < len; i++) {
            sum += nums[i];
            prefix[i] = sum;
        }
        for (int i = 0; i < len; i++) {
            if (i == 0) {
               if (sum - prefix[0] == 0) return 0;
            } else {
                if (prefix[i - 1] == sum - prefix[i]) {
                    return i;
                }
            }
        }
        return -1;
    }
}
```
# 前缀积问题
## 除自身以外数组的乘积
力扣第 238 题「[除自身以外数组的乘积](https://leetcode.cn/problems/product-of-array-except-self/)」
给你一个整数数组 `nums`，返回 数组 `answer` ，其中 `answer[i]` 等于 `nums` 中除 `nums[i]` 之外其余各元素的乘积 。
题目数据 **保证** 数组 `nums`之中任意元素的全部前缀元素和后缀的乘积都在  **32 位** 整数范围内。
- 请 **不要使用除法**，且在 `O(n)` 时间复杂度内完成此题。
---
![[除自身以外数组的乘积.png|800]]
题目要求不能使用除法，所以总乘积去除以 `nums[i]` 的乘积的解法显然不可取的。
如上图，可以将本题拆分为红色部分乘以蓝色部分，所以，不只要保存前缀积，还需要保存后缀的积。
```java
prefix[0] = nums[0]; // 不使用 1，因为可能出现第一个元素为 0 的情况
for (int i = 1; i < len; i++) {
	prefix[i] = prefix[i - 1] * nums[i];
}
int[] sufix = new int[len];
sufix[len - 1] = nums[len - 1];
for (int i = len - 2; i >= 0; i--) {
	sufix[i] = sufix[i + 1] * nums[i];
}
```
此时，除去某个位置的乘积就可以由这样的公式得出：`res[i] = prefix[i - 1] * sufix[i + 1];`
```java
class Solution {
    public int[] productExceptSelf(int[] nums) {
        int len = nums.length;
        int[] prefix = new int[len];
        prefix[0] = nums[0]; // 不使用 1，因为可能出现第一个元素为 0 的情况
        for (int i = 1; i < len; i++) {
            prefix[i] = prefix[i - 1] * nums[i];
        }

        int[] sufix = new int[len];
        sufix[len - 1] = nums[len - 1];
        for (int i = len - 2; i >= 0; i--) {
            sufix[i] = sufix[i + 1] * nums[i];
        }

        int[] res = new int[len];
        res[0] = sufix[1];
        res[len - 1] = prefix[len - 2];
        for (int i = 1; i < len - 1; i++) {
            res[i] = prefix[i - 1] * sufix[i + 1];
        }
        return res;
    }
}
```
## 最后 K 个数的乘积
请你实现一个「数字乘积类」`ProductOfNumbers`，要求支持下述两种方法：
`add(int num)`：将数字 num 添加到当前数字列表的最后面。
`getProduct(int k)`：返回当前数字列表中，最后 k 个数字的乘积。
- 你可以假设当前列表中始终 **至少** 包含 `k` 个数字。
---
本题的难点在于 0 的处理，假设题目中不会出现 0 的话，那只需要返回 `prefix[len - 1] / prefix[len - k - 1]` 即可。
但是如果出现 0 的话，上面的公式就可能会出现除以 0 的情况导致报错。
且如果出现 0，则范围的乘积就一定是 0。
```java
class ProductOfNumbers {
    // 前缀积数组
    // preProduct[i] / preProduct[j] 就是 [i, j] 之间的元素积
    ArrayList<Integer> preProduct = new ArrayList<>();

    public ProductOfNumbers() {
        // 初始化放一个 1，便于计算后续添加元素的乘积
        preProduct.add(1);
    }

    public void add(int num) {
        if (num == 0) {
            // 如果添加的元素是 0，则前面的元素积都废了
            preProduct.clear();
            preProduct.add(1);
            return;
        }
        int n = preProduct.size();
        // 前缀积数组中每个元素
        preProduct.add(preProduct.get(n - 1) * num);
    }

    public int getProduct(int k) {
        int n = preProduct.size();
        if (k > n - 1) {
            // 不足 k 个元素，是因为最后 k 个元素存在 0
            return 0;
        }
        // 计算最后 k 个元素积
        return preProduct.get(n - 1) / preProduct.get(n - k - 1);
    }
}
	```

### 1 对象内存布局
在 HotSpot 虚拟机里，对象在堆内存中的存储布局可以划分为三个部分：**对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）**。
#### 1.1 对象头
HotSpot 虚拟机对象的对象头部分包括两类信息。
**第一类是用于存储对象自身的运行时数据**
- 如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等。
- 这部分数据的长度在 32 位和 64 位的虚拟机（未开启压缩指针）中分别为 32 个比特和 64 个比特，官方称它为 “Mark Word”。
- 对象需要存储的运行时数据很多，其实已经超出了 32、64 位 Bitmap 结构所能记录的最大限度，但对象头里的信息是与对象自身定义的数据无关的额外存储成本，Mark Word 被设计成一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。
**另外一部分是类型指针**
- 即对象指向它的 **元数据的指针**，Java 虚拟机通过这个指针来确定该对象是哪个类的实例。
- 需要注意的是并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身。

![[类的元数据.png]]

如果对象是一个 Java 数组，那**在对象头中还必须有一块用于记录数组长度的数据**，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小。
#### 1.2 实例数据
实例数据部分是对象真正存储的有效信息，也就是我们在**程序代码里面所定义的各种类型的字段内容**，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来。
这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。
HotSpot虚拟机默认的分配顺序为 longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers，OOPs），从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。
如果HotSpot虚拟机的 +XX:CompactFields 参数值为 true（默认就为 true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。
#### 1.3 对齐填充
这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。
**由于HotSpot虚拟机的自动内存管理系统要求任何对象的大小都必须是8字节的整数倍**。对象头部分已经被精心设计成正好是8字节的倍数（1倍或2倍），如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。
### 2 对象的访问定位
 创建对象自然是为了后续使用该对象，我们的 Java 程序会通过栈上的 reference 数据来操作堆上的具体对象。由于reference类型在《Java虚拟机规范》里面只规定了它是一个指向对象的引用，并没有定义这个引用应该通过什么方式去定位、访问到堆中对象的具体位置，所以对象访问方式也是由虚拟机实现而定的。
主流的访问方式主要有使用句柄和直接指针两种：
#### 2.1 使用句柄访问
![[句柄的方式访问 Java 对象.png|600]]

#### 2.2 使用直接指针访问
为了支持这种访问方式，在 Java 堆的对象头中至少需要存储以下信息：Mark Word（包括锁状态、年龄等对象的状态信息），Class Metadata Address（指向类元数据的地址，用于确定对象的类型信息）
而如果使用句柄，类元数据地址不需要存储在对象头中，而是存储在句柄表中。这样可以减少每个对象的内存开销，因为类元数据地址只在句柄表中存储一次，而不是每个对象都要存储。
宁愿多存储一些数据还是希望能够绕过句柄访问的理由是这样的：当使用直接指针的时候，`reference`中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在 `Java` 中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。
![[直接引用的方式访问 Java 对象.png|600]]
>[!note] 关于句柄 
>在计算机科学中，句柄（Handle）是一种用于标识或引用资源的方式，通常用于操作系统、编程语言或软件库中。句柄可以被视为一种间接引用，它指向实际的数据或资源。句柄的主要作用是提供了一种安全和灵活的方式来管理和访问资源，而不需要直接暴露资源的位置或内部结构。 在早期版本的JVM中，对象可以通过句柄来访问。对象句柄是一个指向对象实例的指针，而这个指针实际上是指向另一个包含对象实际地址的结构。这种方式可以提高垃圾回收的效率，因为只需要更新句柄指向的结构即可，而不需要更新所有指向对象的指针。然而，在现代JVM中，许多实现都采用了直接指针的方式，以减少内存开销和提高性能。

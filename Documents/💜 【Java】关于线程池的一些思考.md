## 为什么核心线程数满了不是直接打到最大线程，而是等阻塞队列满了才添加线程呢？
![[线程池的削峰填谷功能.png]]
简单来说，是为了防止突然来的大量任务导致的 CPU 负载频繁的变化，达到一个削峰的效果。
这和 MQ 的其实比较像，在处理可能来的大量的任务的时候，我们需要一个队列将这些任务暂存起来，而不是直接执行，这样能使系统的负载达到一个平缓的状态，不会因为随着任务的增多减少而上下浮动。
## 核心线程数和最大线程数如何设置？
如果我们设置的线程池数量太小的话，如果同一时间有大量任务/请求需要处理，可能会导致大量的请求/任务在任务队列中排队等待执行，甚至会出现任务队列满了之后任务/请求无法处理的情况，或者大量任务堆积在任务队列导致 OOM。
如果我们设置线程数量太大，大量线程可能会同时在争取 CPU 资源，这样会导致大量的上下文切换，从而增加线程的执行时间，影响了整体执行效率。
CPU 密集型简单理解就是利用 CPU 计算能力的任务比如你在内存中对大量数据进行排序。但凡涉及到网络读取，文件读取这类都是 IO 密集型，这类任务的特点是 CPU 计算耗费时间相比于等待 IO 操作完成的时间来说很少，大部分时间都花在了等待 IO 操作完成上；对于这两种任务有一个简单且适用面比较广的方法：
- **CPU** **密集型任务(N+1)：** 这种任务消耗的主要是 CPU 资源，可以将线程数设置为 N（CPU 核心数）+1。比 CPU 核心数多出来的一个线程是为了防止线程偶发的缺页中断，或者其它原因导致的任务暂停而带来的影响。一旦任务暂停，CPU 就会处于空闲状态，而在这种情况下多出来的一个线程就可以充分利用 CPU 的空闲时间。
- **I/O** **密集型任务(2N)：** 这种任务应用起来，系统会用大部分的时间来处理 I/O 交互，而线程在处理 I/O 的时间段内不会占用 CPU 来处理，这时就可以将 CPU 交出给其它线程使用。因此在 I/O 密集型任务的应用中，我们可以多配置一些线程，具体的计算方法是 2N。
除此之外还有一个严谨一点的公式：**最佳线程数= N(1+WT/ST)**
- N：CPU 核心数
- WT：线程等待时间
- ST：线程计算时间
注意：上面的所有都是一个参考，真实的情况并不是简单套公式就可以解决的，而是需要大量的测试；这就引出了一个新的技术：**动态线程池**：
美团技术团队在[《Java 线程池实现原理及其在美团业务中的实践》](https://tech.meituan.com/2020/04/02/java-pooling-pratice-in-meituan.html)这篇文章中介绍到对线程池参数实现可自定义配置的思路和方法。思路是主要对线程池的核心参数实现自定义可配置。这三个核心参数是：
- `corePoolSize` : 核心线程数线程数定义了最小可以同时运行的线程数量。
- `maximumPoolSize` : 当队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。
- `workQueue`: 当新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。
如何支持参数动态配置？ `ThreadPoolExecutor` 提供的下面这些方法。
![[ThreadPoolExecutor 提供的修改线程池参数的方法.png|400]]
格外需要注意的是`corePoolSize`， 程序运行期间的时候，我们调用 `setCorePoolSize（）`这个方法的话，线程池会首先判断当前工作线程数是否大于`corePoolSize`，如果大于的话就会回收工作线程。
另外，你也看到了上面并没有动态指定队列长度的方法，美团的方式是自定义了一个叫做 `ResizableCapacityLinkedBlockIngQueue` 的队列（主要就是把`LinkedBlockingQueue`的 capacity 字段的 final 关键字修饰给去掉了，让它变为可变的）


原本在贫血模型下的开发，常常是不会特别在意一个方法的出入参对象的，也经常是很多个服务共用一个VO对象作为入参，只要这个对象能把我需要的属性信息带进来就可以了。
但在 DDD 的领域模型设计下，领域对象的设计是非常面向对象的。而且在整个风暴事件的四色建模过程也是在以领域对象为驱动进行的。
实体、聚合、值对象，三者位于每个领域下的领域对象内，服务于领域内的领域服务。三个对象定义具体如下；
![[实体、聚合、值对象图例.png]]
# 实体 = 唯一标识 + 状态属性 + 行为动作（功能）
是依托于持久化层数据以领域服务功能目标为指导设计的领域对象，可以简单理解为，就是我们数据库字段中的“一行“。
实体对象是具有业务语义且有唯一标识的对象，跟随于领域服务方法的全生命周期对象。
如；用户PO持久化对象，会涵盖，用户的开户实体、授信实体、额度实体对象。也包括如商品下单时候的购物车实体对象。这个对象也通常是领域服务方法的入参对象。
实体不仅仅包含数据（状态属性），还包含了相关的行为（功能），并且它的标识在整个生命周期中保持不变。
特征：
1. **唯一标识**：实体具有一个可以区分其他实体的标识符。这个标识符可以是一个ID、一个复合键或者是一个自然键，关键是它能够唯一地标识实体实例。
2. **领域标识**：实体的标识通常来源于业务领域，例如用户ID、订单ID等。这些标识符在业务上有特定的含义，并且在系统中是唯一的。
3. **委派标识**：在某些情况下，实体的标识可能是由ORM（对象关系映射）框架自动生成的，如数据库中的自增主键。这种标识符虽然可以唯一标识实体，但它并不直接来源于业务领域。
用途：
1. **表达业务概念**：实体用于在软件中表达具体的业务概念，如用户、订单、交易等。通过实体的属性和行为，可以描述这些业务对象的特征和能力。
2. **封装业务逻辑**：实体不仅仅承载数据，还封装了业务规则和逻辑。这些逻辑包括验证数据的有效性、执行业务规则、计算属性值等。这样做的目的是保证业务逻辑的集中和一致性。
3. **保持数据一致性**：实体负责维护自身的状态和数据一致性。它确保自己的属性和关联关系在任何时候都是正确和完整的，从而避免数据的不一致性。
实现手段：
1. **定义实体类**：在代码中定义一个类，该类包含实体的属性、构造函数、方法等。
2. **实现唯一标识**：为实体类提供一个唯一标识的属性，如ID，并确保在实体的生命周期中这个标识保持不变。
3. **封装行为**：在实体类中实现业务逻辑的方法，这些方法可以操作实体的状态，并执行相关的业务规则。
4. **使用ORM框架**：利用ORM框架将实体映射到数据库表中，这样可以简化数据持久化的操作。
5. **实现领域服务**：对于跨实体或跨聚合的操作，可以实现领域服务来处理这些操作，而不是在实体中直接实现。
6. **使用领域事件**：当实体的状态发生变化时，可以发布领域事件，这样可以通知其他部分的系统进行相应的处理。
例如，订单对象（注意，这里说的是订单的对象，不是这个类）
```java
public class Order {
    private String orderId; // Unique identifier
    private String status;
    private double amount;

    // Constructors, getters, setters
}
```
# 值对象
这个对象在领域服务方法的生命周期过程内是不可变对象，也没有唯一标识。
它通常是配合实体对象使用。如为实体对象提供对象属性值的描述，比如某个用户的电话号码。
所以在开发值对象的时候，通常不会提供 setter 方法，而是提供构造函数或者 Builder 方法来实例化对象。
这个对象通常不会独立作为方法的入参对象，但做可以独立作为出参对象使用。
值对象是由一组属性组成的，它们共同描述了一个领域概念。
与实体（Entity）不同，值对象不需要有一个唯一的标识符来区分它们。
值对象通常是不可变的，这意味着一旦创建，它们的状态就不应该改变。
特征：
1. **不可变性（Immutability）**：值对象一旦被创建，它的状态就不应该发生变化。这有助于保证领域模型的一致性和线程安全性。
2. **等价性（Equality）**：值对象的等价性不是基于身份或引用，而是基于对象的属性值。如果两个值对象的所有属性值都相等，那么这两个对象就被认为是等价的。
3. **替换性（Replaceability）**：由于值对象是不可变的，任何需要改变值对象的操作都会导致创建一个新的值对象实例，而不是修改现有的实例。
4. **侧重于描述事物的状态**：值对象通常用来描述事物的状态，而不是事物的唯一身份。
5. **可复用性（Reusability）**：值对象可以在不同的领域实体或其他值对象中重复使用。
用途：
1. 金额和货币（如价格、工资、费用等）
2. 度量和数据（如重量、长度、体积等）
3. 范围或区间（如日期范围、温度区间等）
4. 复杂的数学模型（如坐标、向量等）
5. 任何其他需要封装的属性集合
实现手段：
1. **定义不可变类**：确保类的所有属性都是私有的，并且只能通过构造函数来设置。
2. **重写equals和hashCode方法**：这样可以确保值对象的等价性是基于它们的属性值，而不是对象的引用。
3. **提供只读访问器**：只提供获取属性值的方法，不提供修改属性值的方法。
4. **使用工厂方法或构造函数创建实例**：这有助于确保值对象的有效性和一致性。
5. **考虑序列化支持**：如果值对象需要在网络上传输或存储到数据库中，需要提供序列化和反序列化的支持。
例如，地址信息：
```java
public class Address {
    private String street;
    private String city;
    private String zipCode;
    // Constructors, getters, no setters (immutable)
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Address address = (Address) o;
        return street.equals(address.street) &&
               city.equals(address.city) &&
               zipCode.equals(address.zipCode);
    }
    @Override
    public int hashCode() {
        return Objects.hash(street, city, zipCode);
    }
}

```
# 聚合
当你对数据库的操作需要使用到多个实体时，可以创建聚合对象。一个聚合对象，代表着一个数据库事务，具有事务一致性。聚合中的实体可以由聚合提供创建操作，实体也被称为聚合根对象。一个订单的聚合，会涵盖；下单用户实体对象、订单实体、订单明细实体和订单收货四级地址值对象。而那个作为入参的购物车实体对象，已经被转换为实体对象了。—— 聚合内事务一致性，聚合外最终一致性。
概念：聚合是领域模型中的一个关键概念，它是一组具有内聚性的相关对象的集合，这些对象一起工作以执行某些业务规则或操作。聚合定义了一组对象的边界，这些对象可以被视为一个单一的单元进行处理。
特征：
1. **一致性边界**：聚合确保其内部对象的状态变化是一致的。当对聚合内的对象进行操作时，这些操作必须保持聚合内所有对象的一致性。
2. **根实体**：每个聚合都有一个根实体（Aggregate Root），它是聚合的入口点。根实体拥有一个全局唯一的标识符，其他对象通过根实体与聚合交互。
3. **事务边界**：聚合也定义了事务的边界。在聚合内部，所有的变更操作应该是原子的，即它们要么全部成功，要么全部失败，以此来保证数据的一致性。
用途：
1. **封装业务逻辑**：聚合通过将相关的对象和操作封装在一起，提供了一个清晰的业务逻辑模型，有助于业务规则的实施和维护。
2. **保证一致性**：聚合确保内部状态的一致性，通过定义清晰的边界和规则，聚合可以在内部强制执行业务规则，从而保证数据的一致性。
3. **简化复杂性**：聚合通过组织相关的对象，简化了领域模型的复杂性。这有助于开发者更好地理解和扩展系统。
 实现手段：
1. **定义聚合根**：选择合适的聚合根是实现聚合的第一步。聚合根应该是能够代表整个聚合的实体，并且拥有唯一标识。
2. **限制访问路径**：只能通过聚合根来修改聚合内的对象，不允许直接修改聚合内部对象的状态，以此来维护边界和一致性。
3. **设计事务策略**：在聚合内部实现事务一致性，确保操作要么全部完成，要么全部回滚。对于聚合之间的交互，可以采用领域事件或其他机制来实现最终一致性。
4. **封装业务规则**：在聚合内部实现业务规则和逻辑，确保所有的业务操作都遵循这些规则。
5. **持久化**：聚合根通常与数据持久化层交互，以保存聚合的状态。这通常涉及到对象-关系映射（ORM）或其他数据映射技术。
例如，购物车：
```java
public class ShoppingCart {
    private String cartId; // Aggregate Root ID
    private List<CartItem> items;

    public void addItem(CartItem item) {
        items.add(item);
    }

    public void removeItem(CartItem item) {
        items.remove(item);
    }

    // Other business logic
}

public class CartItem {
    private String productId;
    private int quantity;

    // Constructors, getters, setters
}
```
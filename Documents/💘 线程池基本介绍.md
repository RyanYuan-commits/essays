## 1 为什么需要线程池？

和连接池相同的池化思想, 复用思想.

创建和销毁线程的开销很大, 通过重用已有的线程可以 **减少资源消耗**, 同时还能对线程进行统一管理和控制.

## 2 线程池参数

![[线程池参数.png|700]]

### 2.1 任务队列

`ArrayBlockingQueue`: 基于数组的固定大小阻塞队列, 通过限制长度可以避免任务的无限量增长.

`LinkedBlockingQueue`: 基于链表的容量可选阻塞队列, 默认容量为 `Integer.MAX_VALUE`, 适合任务处理速度波动较大时使用.

`SynchronousQueue`: 不存储元素的同步队列, 队列中有元素的时候, 其他元素的 `put` 方法会一直阻塞, 直到其他线程从队列中通过 `take` 取出元素.

`PriorityBlockingQueue`: 无界阻塞队列, 按照元素的优先级进行排序, 优先级最高的元素最先被取出, 比较基于 `Comparator` 接口.

`DelayQueue`: 无界阻塞队列, 插入时指定过期时间, 元素必须等待延迟时间到期后才能被取出.

### 2.2 线程池的拒绝策略

当任务队列已满, 且线程池内的线程数达到最大线程数的时候, 会触发拒绝策略.

```Java
public interface RejectedExecutionHandler {
    void rejectedExecution(Runnable r, ThreadPoolExecutor executor);
}
```

拒绝策略是实现了 `RejectedExecutionHandler` 接口的类, 在 `ThreadPoolExecutor` 中, 提供了一些默认拒绝策略实现, 具体有:

- `AbortPolicy`: 抛出 `RejectedExecutionException` 异常;
- `CallerRunsPolicy`: 任务由提交任务的线程来继续执行;
- `DiscardOldestPolicy`: 丢弃阻塞队列中最旧的任务, 然后尝试重新提交被拒绝的任务;
- `DiscardPolicy`: 默默丢弃掉任务而不做任何的处理.

## 3 Executors 创建的线程池

 `FixedThreadPool` 创建一个固定大小的线程池. 当提交任务时, 如果线程池中的线程都在工作, 新任务就会被放入一个无界队列中等待. 如果某个线程执行完毕, 它就会从队列中取出下一个任务继续执行. 它的优点是可控性强, 可以避免因线程数量过多而导致的资源耗尽. 

`SingleThreadExecutor` 创建一个只有一个线程的线程池. 它的行为与 `FixedThreadPool(1)` 类似, 但它保证了所有任务都会按照提交的顺序串行执行. 这个线程池非常适合需要确保任务顺序执行的场景. 如果唯一的线程因为异常而终止, 线程池会创建一个新的线程来替代它. 

`CachedThreadPool` 创建一个可缓存的线程池. 它会根据需要创建新的线程, 但如果一个线程在 60 秒内没有执行任务, 它就会被回收. 如果一个任务提交进来, 但所有线程都在忙碌, 它会立即创建一个新线程来执行任务. 这个线程池的优点是高效, 适合执行大量短期的异步任务. 但由于线程数量是动态变化的, 如果任务提交速率过快, 可能会创建过多的线程, 导致系统资源耗尽. 

`ScheduledThreadPool` 创建一个固定大小的线程池, 用于支持定时和周期性任务的执行. 它提供了 `schedule()`、`scheduleAtFixedRate()` 和 `scheduleWithFixedDelay()` 等方法, 可以用来在指定延迟后或按照固定的时间间隔来执行任务. 它适用于需要执行后台定时任务的场景. 

## 5 线程池生命周期

Java 线程池的状态主要由 ThreadPoolExecutor 类来管理，ThreadPoolExecutor 是实现线程池功能的核心类，它的线程池状态可以根据当前线程池的执行情况而变化。线程池状态的变化是通过 ThreadPoolExecutor 中的一些重要字段和方法来控制的。

ThreadPoolExecutor 的核心状态是由 getPoolSize()、getActiveCount() 等方法所反映，具体有以下几种状态：

### 5.1 RUNNING 运行状态

线程池处于运行状态时，线程池接受新的任务，并且可以处理已经在队列中的任务。

当线程池正在处理任务，且没有被关闭或终止时，处于此状态。

线程池在启动时进入此状态，直到调用 shutdown() 或 shutdownNow() 进行关闭。

### 5.2 SHUTDOWN 关闭状态

线程池进入 **关闭** 状态，不再接收新的任务，但已经提交的任务会继续执行直到完成。

调用 shutdown() 方法后，线程池会进入此状态。此时新提交的任务不会被接收，但已在队列中的任务会继续执行。

从 RUNNING 转换为 SHUTDOWN 状态。

### 5.3 STOP 停止状态

线程池完全停止，所有正在执行的任务都会被中断，队列中的任务也会被丢弃。

调用 shutdownNow() 方法后，线程池会进入 STOP 状态。它会立即尝试停止所有正在执行的任务，并且丢弃所有排队等待的任务。

从 SHUTDOWN 转换为 STOP 状态。

### 5.4 TIDYING 整理状态

线程池中的所有任务都已经完成，且没有更多的任务等待执行。在这个状态下，线程池将会清理掉所有资源。

当线程池在 SHUTDOWN 或 STOP 状态下，且线程池中的所有线程都已经终止（getPoolSize() == 0）时，线程池进入 TIDYING 状态。

从 SHUTDOWN 或 STOP 转换为 TIDYING 状态。

### 5.5 TERMINATE 完全终止状态

线程池已经完全关闭，并且没有任务正在运行。

当线程池进入 TIDYING 状态后，清理完资源，线程池处于完全终止的状态。

从 TIDYING 转换为 TERMINATED 状态。

### 5.6 状态转化

线程池的状态转换通常发生在以下几个关键的操作时：

1. `RUNNING` → `SHUTDOWN`：通过 `shutdown` 方法触发。线程池停止接收新任务，但已提交的任务仍会执行完毕。
2. `SHUTDOWN` → `STOP`：通过 `shutdownNow` 方法触发。线程池尝试停止所有正在执行的任务，并清空任务队列中的待执行任务。
3. `SHUTDOWN` → `TIDYING`：当线程池停止接收新任务，并且所有任务执行完成，线程池中没有线程在运行时，进入 `TIDYING` 状态。
4. `TIDYING` → `TERMINATED`：当线程池中的所有线程结束并且所有资源被清理完，线程池进入 `TERMINATED` 状态。
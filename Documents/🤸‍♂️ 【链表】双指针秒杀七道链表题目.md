# 涉及题目
本文总结一下单链表的基本技巧，每个技巧都对应着至少一道算法题：
1、合并两个有序链表
2、链表的分解
3、合并 `k` 个有序链表
4、寻找单链表的倒数第 `k` 个节点
5、寻找单链表的中点
6、判断单链表是否包含环并找出环起点
7、判断两个单链表是否相交并找出交点
# 合并两个有序链表
将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。
这题比较简单，我们直接看解法：
```java
class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummyHead = new ListNode();
        ListNode cursor = dummyHead;
        while (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                cursor.next = list1;
                list1 = list1.next;
            } else {
                cursor.next = list2;
                list2 = list2.next;
            }
            cursor = cursor.next;
        }
        if (list1 != null) cursor.next = list1;
        else if(list2 != null) cursor.next = list2;
        return dummyHead.next;
    }
}
```
**代码中还用到一个链表的算法题中是很常见的「虚拟头结点」技巧，也就是 `dummy` 节点**。你可以试试，如果不使用 `dummy` 虚拟节点，代码会复杂一些，需要额外处理指针 `p` 为空的情况。而有了 `dummy` 节点这个占位符，可以避免处理空指针的情况，降低代码的复杂性。
>[!note] 什么时候需要用虚拟头结点？
>当你需要创造一条新链表的时候，可以使用虚拟头结点简化边界情况的处理。
比如说，让你把两条有序链表合并成一条新的有序链表，是不是要创造一条新链表？再比你想把一条链表分解成两条链表，是不是也在创造新链表？这些情况都可以使用虚拟头结点简化边界情况的处理。

# 单链表的分解
力扣第 86 题：[分割链表](https://leetcode.cn/problems/partition-list/)
给你一个链表的头节点 `head` 和一个特定值 `x` ，请你对链表进行分隔，使得所有 **小于** `x` 的节点都出现在 **大于或等于** `x` 的节点之前。
应当 **保留** 两个分区中每个节点的初始相对位置。
例如：
```
输入：head = [1,4,3,2,5,2], x = 3
输出：[1,2,2,4,3,5]
```
上一题是将两个链表合并，而本题是要将一个链表分割成大于 x 和小于 x 的两个链表，最后再将其合并起来就得到了想要的结果
```java
class Solution {
    public ListNode partition(ListNode head, int x) {
        // 将链表分割成小于等于 x 的链表和大于等于 x 的链表
        ListNode dummy1 = new ListNode();
        ListNode dummy2 = new ListNode();
        ListNode cursor1 = dummy1;
        ListNode cursor2 = dummy2;
        while (head != null) {
            if (head.val < x) {
                cursor1.next = head;
                cursor1 = cursor1.next;
            } else {
                cursor2.next = head;
                cursor2 = cursor2.next;
            }
            // 这里不能直接移动 head
            // head = head.next; 将会导致链表成环
            ListNode temp = head.next;
            head.next = null;
            head = temp;
        }
        // 将小的部分与大的部分拼起来
        cursor1.next = dummy2.next;
        return dummy1.next;
    }
}
```
上面的代码中提到，如果直接移动 head 指针，将会导致链表成环，其实，是否成环就看是否执行了类似这样的语句：
```java
p1.next = head;
head.next = head;
p2.next = head;
```
而此时循环恰好结束，这就导致两个链表在拼接之前还存在连接：
![[链表成环问题.png|700]]
# 合并 K 个有序链表
对应力扣第 23 题，合并 K 个升序链表：[https://leetcode.cn/problems/merge-k-sorted-lists/description/](https://leetcode.cn/problems/merge-k-sorted-lists/description/)
给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。
本题有两种思路，第一种就是通过分治的方法将链表进行两两合并，最后合成一个大的链表，类似于归并排序的思路。
```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
       return merge(lists, 0, lists.length - 1); 
    }
    public ListNode merge(ListNode[] list, int l, int r) {
        if (l == r) return list[l];
        if (l > r) return null;
        int mid = (l + r) / 2;
        ListNode rightMerge = merge(list, mid + 1, r);
        ListNode leftMerge = merge(list, l, mid);
        return mergeTwoLists(rightMerge, leftMerge);
    }
}
```
剩余的部分其实就是前面做到过的合并两个链表：
```java
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode resList = new ListNode(), p = resList;
        ListNode p1 = list1, p2 = list2;
        if (list1 == null || list2 == null) return list1 == null ? list2 : list1;
        while (p1 != null && p2 != null) {
            if (p1.val > p2.val) {
                p.next = p2;
                p2 = p2.next;
            } else {
                p.next = p1;
                p1 = p1.next;
            }
            p = p.next;
        }
        if (p1 != null) p.next = p1;
        else p.next = p2;
        return resList.next;
    }
```
第二种思路的借鉴合并两个链表的思路，每次拿到 K 个链表中最小的元素，这里就可以借助堆来实现：
[[🐮 Java 中的优先队列]]
需要注意的有两点：
- 构造参数中传入的初始长度不能为 0
- 优先队列中不能添加 null
```java
class Solution {
    public ListNode mergeKLists(ListNode[] lists) {
        int len = lists.length;
        if (len == 0) return null;
        PriorityQueue<ListNode> listNodes = new PriorityQueue<>(len, Comparator.comparingInt(o -> o.val));
        ListNode dummyNode = new ListNode();
        ListNode p = dummyNode;
        // 先将所有链表的第一个元素入队
        for (ListNode head : lists) {
            if (head == null) continue;
            listNodes.add(head);
        }
        while (!listNodes.isEmpty()) {
            // 获取到队列中最小的元素
            ListNode cursor = listNodes.poll();
            ListNode next = cursor.next;
            cursor.next = null;
            if (next != null) listNodes.add(next);
            p.next = cursor;
            p = p.next;
        }
        return dummyNode.next;
    }
}
```
# 单链表的倒数第 k 个节点
从前往后寻找单链表的第 `k` 个节点很简单，一个 for 循环遍历过去就找到了，但是如何寻找从后往前数的第 `k` 个节点呢？
如果还是按照顺序遍历的方式，假设链表的总个数为 `n`，那就需要 `n - k + 1` 步就可以到达倒数第 `k` 个节点。
但是如果要得到总个数 `n`，就需要先遍历一遍链表，那有没有更巧妙的办法呢？
我们可以让节点1先出发，这样，当它走到链表末尾的时候，走的路程就是 `n + 1`；而节点2在它走了 k 步的时候出发；这样，当节点 1 到达末尾的时候，节点 2 恰好就走了 `n - k + 1` 个节点。
通过这个思路，我们可以写出一个方法，能够找到一个链表的倒数第 k 个节点
```java
public ListNode findLast(ListNode node, int k) {
	ListNode cursor1 = head;
	// 先走 k 步
	for (int i = 0; i < k; i++) cursor1 = cursor1.next;
	ListNode cursor2 = head;
	while (cursor1 != null) {
		cursor1 = cursor.next;
		cursor2 = cursor2.next;
	}
	return cursor2;
}
```
具体的题目可以看力扣第 19 题：删除链表的倒数第 N 个节点：[https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)
```
给你一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点。
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```
要删除链表中的一个节点，需要拿到的是这个节点的前一个节点，所以本题中需要拿到的节点就是第 `n - k` 个节点（为了统一，这里仍然使用 n 和 k 来分别代表链表节点总个数和倒数第 k 个节点，在本题中，公式中的 k 实际上是题目给的 n）。
按照上面的思路就可以得到这样的代码：
```java
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode();
        dummy.next = head;
        ListNode cursor1 = dummy;
        ListNode cursor2 = dummy;
        for (int i = 0; i < n; i++) cursor1 = cursor1.next;
        while (cursor1.next != null) {
            cursor1 = cursor1.next;
            cursor2 = cursor2.next;
        }
        cursor2.next = cursor2.next.next;
        return dummy.next;
    }
}
```
# 单链表的中点
这类题目要求的是找到中间的那个节点，对应力扣第 876 题，链表的中间节点：[https://leetcode.cn/problems/middle-of-the-linked-list/description/](https://leetcode.cn/problems/middle-of-the-linked-list/description/)
其实可以借助前面单链表倒数第 k 个节点的双指针思路，用两个指针，一个指针一次移动一个节点，另一个指针一次移动两个节点。
当快的指针到达终点的时候，另一个指针就会到达中间的节点。
除此之外，还需要对边界条件进行一些限定。
```java
class Solution {
    public ListNode middleNode(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next;   
            if (fast == null) break;
            fast = fast.next;
        }
        return slow;
    }
}
```
# 判断链表中是否存在环
判断链表是否存在环也是一个经典的问题了，解决它的方法也是使用快慢指针，如果快慢指针能够相遇，则说明链表中存在环。
原因就是，如果链表中存在环形结构，当快慢指针全部进入这个环形结构的时候，就变成了一个速度相差为 1 的追逐问题了，在距离为整数的赛道上，这个追逐问题是一定有结果的。
对应的题目有力扣的第 141 题，环形链表 [https://leetcode.cn/problems/linked-list-cycle/](https://leetcode.cn/problems/linked-list-cycle/)
```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
            // 检测两个指针是否相等
            if (slow == fast) return true;
        }
        return false;
    }
}
```
本题的有一个进阶的版本，不只需要判断链表中是否存在环，还需要判断这个环的起点，对应的是力扣第 142 题，环形链表 II：[https://leetcode.cn/problems/linked-list-cycle-ii/description/](https://leetcode.cn/problems/linked-list-cycle-ii/description/)
第一种思路非常的简单粗暴，我们将所有遍历到的节点都记录下来，在后续的遍历过程中，当第一次遍历到前面遍历的节点的时候，这个节点就是入口：
```java
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode cursor = head;
        Set<ListNode> memory = new HashSet<>();
        while (cursor != null) {
            if (memory.contains(cursor)) {
                return cursor;
            }
            memory.add(cursor);
            cursor = cursor.next;
        }
        return null;
    }
}
```
第二种思路就精妙一些，一开始还是指定一个快指针和一个慢指针，当快慢指针相遇时，让其中任一个指针指向头节点，然后让它俩以相同速度前进，再次相遇时所在的节点位置就是环开始的位置。
我们假设快慢指针相遇时，慢指针 `slow` 走了 `k` 步，那么快指针 `fast` 一定走了 `2k` 步，`fast` 一定比 `slow` 多走了 `k` 步，这多走的 `k` 步其实就是 `fast` 指针在环里转圈圈，所以 `k` 的值就是环长度的「整数倍」。
![[环形链表 II 图一.png|600]]
假设相遇点距环的起点的距离为 `m`，那么结合上图的 `slow` 指针，环的起点距头结点 `head` 的距离为 `k - m`，也就是说如果从 `head` 前进 `k - m` 步就能到达环起点。
巧的是，如果从相遇点继续前进 `k - m` 步，也恰好到达环起点。因为结合上图的 `fast` 指针，从相遇点开始走k步可以转回到相遇点，那走 `k - m` 步肯定就走到环起点了；
所以，只要我们把快慢指针中的任一个重新指向 `head`，然后两个指针同速前进，`k - m` 步后一定会相遇，相遇之处就是环的起点了。
![[环形链表 II 图二.png|600]]
# 判断两个链表是否相交
假设两个链表分别为 A 和 B，不相交的部分长度分别为 m 和 n，相交部分的长度为 k：
![[链表相交]]
还是使用双指针的思路，为了让两个指针在交点上相遇，可以让 p1 走到终点，然后再从 B 出发；p2 也是走到终点，从 A 出发，如果有两个链表有交点的话，那它们 **第一次相遇** 的位置就是两个链表的交点。
因为它们此时都走了 m + k + n 的距离；而如果链表没有交点的话，则它们不会相遇，而是会同时为 null。
所以在实现的时候，这就是一个判断的思路，也就是判断它们是在某个节点相等还是在 null 的时候相等。
```java
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode p1 = headA;
        ListNode p2 = headB;
        while (p1 != p2) {
            p1 = p1 == null ? headB : p1.next;
            p2 = p2 == null ? headA : p2.next;
        }
        return p1;
    }
}
```
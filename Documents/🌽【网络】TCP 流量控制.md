### 1 滑动窗口
#### 1.1 引入原因
采用一问一答的方式来进行通信效率太低，数据包的**往返时间越长，通信的效率就越低**。
为解决这个问题，TCP 引入了**窗口**这个概念。即使在往返时间较长的情况下，它也不会降低网络通信的效率。
那么有了窗口，就可以指定窗口大小，窗口大小就是指 **无需等待确认应答，而可以继续发送数据的最大值**。

假设窗口大小为 `3` 个 TCP 段，那么发送方就可以「连续发送」 `3` 个 TCP 段，并且中途若有 ACK 丢失，可以通过「下一个确认应答进行确认」。
比如发送的数据段的序号是 500、600、700，而数据 600 的 ACK 丢失，但是后续收到 700 的 ACK，仍然是可以确认数据 600 的发送成功的，这就是「累计发送」和「累计应答」机制。
#### 1.2 窗口结构
##### 发送方的滑动窗口
![[发送方的滑动窗口.png|800]]
- #1 是已发送并收到 ACK确认的数据：1~31 字节
- #2 是已发送但未收到 ACK确认的数据：32~45 字节
- #3 是未发送但总大小在接收方处理范围内（接收方还有空间）：46~51字节
- #4 是未发送但总大小超过接收方处理范围（接收方没有空间）：52字节以后
##### 接收方的滑动窗口
![[接收方的滑动窗口.png|800]]
- #1 + #2 是已成功接收并确认的数据（等待应用进程读取）；
- #3 是未收到数据但可以接收的数据；
- #4 未收到数据并不可以接收的数据；
### 2 流量控制
#### 2.1 操作系统缓冲区与滑动窗口
前面的流量控制例子，我们假定了发送窗口和接收窗口是不变的，但是实际上，发送窗口和接收窗口中所存放的字节数，都是放在操作系统内存缓冲区中的，而操作系统的缓冲区，会**被操作系统调整**。
当应用进程没办法及时读取缓冲区的内容时，也会对我们的缓冲区造成影响。
如果发生了先减少缓存，再收缩窗口，就会出现丢包的现象。
为了防止这种情况发生，TCP 规定是不允许同时减少缓存又收缩窗口的，而是采用先收缩窗口，过段时间再减少缓存，这样就可以避免了丢包情况。
#### 2.2 窗口关闭
##### 窗口关闭带来的问题
在前面我们都看到了，TCP 通过让接收方指明希望从发送方接收的数据大小（窗口大小）来进行流量控制。
如果窗口大小为 0 时，就会阻止发送方给接收方传递数据，直到窗口变为非 0 为止，这就是窗口关闭。
接收方向发送方通告窗口大小时，是通过 `ACK` 报文来通告的，当接收方处理完数据后，会向发送方通告一个窗口非 0 的 ACK 报文，如果这个通告窗口的 ACK 报文在网络中丢失了，那麻烦就大了。
因为 ACK 报文不会触发重传，而发送方还没有收到 ACK 就会造成死锁的情况。
##### 解决方式
为了解决这个问题，TCP 为每个连接设有一个持续定时器，只要 TCP 连接一方收到对方的零窗口通知，就启动持续计时器。
如果持续计时器超时，就会发送**窗口探测 ( Window probe ) 报文**，而对方在确认这个探测报文时，给出自己现在的接收窗口大小。
- 如果接收窗口仍然为 0，那么收到这个报文的一方就会重新启动持续计时器；
- 如果接收窗口不是 0，那么死锁的局面就可以被打破了。
窗口探测的次数一般为 3 次，每次大约 30-60 秒（不同的实现可能会不一样）。如果 3 次过后接收窗口还是 0 的话，有的 TCP 实现就会发 `RST` 报文来中断连接。
#### 2.3 糊涂窗口综合征
如果接收方太忙了，来不及取走接收窗口里的数据，那么就会导致发送方的发送窗口越来越小。
到最后，**如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是糊涂窗口综合症**。
要知道，我们的 `TCP + IP` 头有 `40` 个字节，为了传输那几个字节的数据，要搭上这么大的开销，这太不经济了。
解决这种情况就需要同时解决下面的两个问题：
- 接收方可以通告一个小的窗口：当窗口大小小于，也就是小于 MSS 与 1/2 缓存大小中的最小值时，就会向发送方通告窗口为 `0`，也就阻止了发送方再发数据过来。
- 而发送方可以发送小数据：使用 Nagle 算法，该算法的思路是延时处理，发送消息的条件是要等到窗口大小 >= `MSS` 并且 数据大小 >= `MSS` **或者** 收到之前发送数据的 `ack` 回包。
## 1 记忆集
记忆集与卡表是为了 **解决对象跨代引用所带来的问题** 而提出的，当需要执行新生代垃圾回收的时候，老年代中的对象可能会存在对新生代对象的引用，为了避免把整个老年代加进 GC Roots 扫描范围，垃圾收集器在新生代中建立了名为记忆集的数据结构。
记忆集是一种用于记录 **从非收集区域指向收集区域** 的指针集合的抽象数据结构。如果我们不考虑效率和成本的话，最简单的实现可以用 **非收集区域** 中所有含跨代引用的对象数组来实现这个数据结构。
而在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要这么高的精度。
下面列举了一些可供选择的记录精度，记忆集中会存储这些含有跨代指针的区域，选择合适的精度可以大大节省空间：
- 字长精度：精确到一个机器字长，该字是否包含跨代指针。
- 对象精度：精确到一个对象，该对象里是否有字段含有跨代指针。
- 卡精度：精确到一块内存区域，该区域内是否有对象含有跨代指针。
## 2 卡表
第三种“卡精度”所指的是用一种称为 “卡表” 的方式去实现记忆集，这也是目前最常用的一种记忆集实现形式，一些资料中甚至直接把它和记忆集混为一谈，记忆集其实是一种“ 抽象”的数据结构，只定义了记忆集的行为意图，并没有定义其行为的具体实现，卡表就是记忆集的一种**具体实现**，它定义了记忆集的记录精度、与堆内存的映射关系等。
卡表的基本构成单位是卡页，一个卡页的内存中也通常包含不止一个对象，但只要卡页内有一个或多个对象的字段存在着跨代指针，那就卡表中对应这个卡页的数组元素的值标识为1，称为这个卡页元素变脏(Dirty)，没有则标识为 0。在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入 GC Roots 中一并扫描。
## 3 更新时机
卡表元素何时变脏的答案是很明确的：有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻。
那如何在对象赋值的那一刻去更新维护卡表呢?
假如是解释执行的字节码，那相对好处理，虚拟机负责每条字节码指令的执行，有充分的介入空间；
但是在编译执行的过程中，经过即时编译后的代码已经是纯粹的机器指令流了，这就必须找到一个在机器码层面的手段，把维护卡表的动作放到每一个赋值操作之中。
### 3.1 写屏障
在 HotSpot 虚拟机里是通过写屏障技术维护卡表状态的。
写屏障可以看作在虚拟机层面对 “引用类型字段赋值” 这个动作的 AOP 切面，在引用对象赋值时会产生一个环形通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。
在赋值前的部分的写屏障叫作写前屏障(Pre-Write Barrier)，在赋值后的则叫作写后屏障(Post-Write Barrier)。HotSpot 虚拟机的许多收集器中都有使用到写屏障，但直至 G1 收集器出现之前，其他收集器都只用到了写后屏障。
应用写屏障后，虚拟机就会为所有赋值操作生成相应的指令，一旦收集器在写屏障中增加了更新卡表操作，无论更新的是不是老年代对新生代对象的引用，每次只要对引用进行更新，就会产生额外的开销，不过这个开销与 Minor GC 时扫描整个老年代的代价相比还是低得多的。
### 3.2 伪共享问题
除了写屏障的开销外，卡表在高并发场景下还面临着“伪共享”(False Sharing)问题。伪共享是处理并发底层细节时一种经常需要考虑的问题，现代中央处理器的缓存系统中是以缓存行(Cache Line) 为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响(写回、无效化或者同步)而导致性能降低，这就是伪共享问题。
假设处理器的缓存行大小为 64 字节，由于一个卡表元素占 1 个字节，64个卡表元素可能共享同一个缓存行。这 64 个卡表元素对应的卡页总的内存为32KB(64×512字节)，也就是说如果不同线程更新的对象正好处于这32KB的内存区域内，就会导致更新卡表时正好写入同一个缓存行而影响性能。
为了避免伪共享问题，一种简单的解决方案是不采用无条件的写屏障，而是先检查卡表标记，只有当该卡表元素未被标记过时才将其标记为变脏，即将卡表更新的逻辑变为以下代码所示:
```java
if (CARD_TABLE [this address >> 9] != 0) 
CARD_TABLE [this address >> 9] = 0;
```
在 JDK 7 之后，HotSpot虚拟机增加了一个新的参数`-XX:+UseCondCardMark`，用来决定是否开启卡表更新的条件判断，开启会增加一次额外判断的开销，但能够避免伪共享问题，两者各有性能损耗，是否打开要根据应用实际运行情况来进行测试权衡。
# 顺/逆时针旋转矩阵
先看另一道谷歌曾经考过的算法题热热身：
给你一个包含若干单词和空格的字符串 `s`，请你写一个算法，**原地**反转所有单词的顺序。
比如输入 `hello world`，返回的答案应该是：
```java
world hello
```
常规的方式是把 `s` 按空格 `split` 成若干单词，然后 `reverse` 这些单词的顺序，最后把这些单词 `join` 成句子。但这种方式使用了额外的空间，并不是「原地反转」单词。
巧妙的做法应该是，先将 s 单词反转，再将每个单词单独反转：
```java
dlrow olleh
world hello
```
对应力扣第 151 题「[反转在字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string/)」：
给你一个字符串 `s` ，请你反转字符串中 **单词** 的顺序。
**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。输入字符串 `s`中可能会存在前导空格、尾随空格或者单词间的多个空格。返回的结果字符串中，单词间应当仅用单个空格分隔，且不包含任何额外的空格。
```
示例 1：
输入：s = "the sky is blue"
输出："blue is sky the"
示例 2：
输入：s = "  hello world  "
输出："world hello"
解释：反转后的字符串中不能存在前导空格和尾随空格。
示例 3：
输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，反转后的字符串需要将单词间的空格减少到仅有一个。
```
本题最优的解法是正向的去遍历，然后逆向的添加：
```java
class Solution {
    public String reverseWords(String s) {
        char[] source = s.toCharArray();
        char[] newArr = new char[source.length + 1];
        int len = 0;
        int cursor = source.length - 1;
        while (cursor >= 0) {
            while (cursor >= 0 && source[cursor] == ' ') cursor--;
            int right = cursor;
            while (cursor >= 0 && source[cursor] != ' ') cursor--;
            for (int i = cursor + 1; i <= right; i++) {
                newArr[len++] = source[i];
                if (i == right) newArr[len++] = ' ';
            }
        }
        if (len == 0) return "";
        else {
            return new String(newArr, 0, len - 1);
        }
    }
}
```
我们可以先将 `n x n` 矩阵 `matrix` 按照左上到右下的对角线进行镜像对称：
![[旋转矩阵图一.png|600]]
然后再对矩阵的每一行进行反转：
![[旋转图像图二.png|600]]
发现结果就是 `matrix` 顺时针旋转 90 度的结果：
![[旋转矩阵图三.png|600]]
翻译成代码就是这样：
```java
class Solution {
    public void rotate(int[][] matrix) {
       for (int i = 0; i < matrix.length; i++) {
        for (int j = i; j < matrix.length; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
       }
       int left = 0;
       int right = matrix.length - 1;
       int temp;
       while (left < right) {
        for (int i = 0; i < matrix.length; i++) {
            temp = matrix[i][left];
            matrix[i][left] = matrix[i][right];
            matrix[i][right] = temp;
        }
        left++;
        right--;
       } 
    }
}
```
如果需要逆时针旋转的话，只需要将按照另一条对角线来翻转，然后交换每一行即可：
```java
int n = matrix.length;
        // 沿左下到右上的对角线镜像对称二维矩阵
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n - i; j++) {
                // swap(matrix[i][j], matrix[n-j-1][n-i-1])
                int temp = matrix[i][j];
                matrix[i][j] = matrix[n - j - 1][n - i - 1];
                matrix[n - j - 1][n - i - 1] = temp;
            }
        }
```
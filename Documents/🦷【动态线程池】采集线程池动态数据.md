# 项目结构
- 项目地址：[https://github.com/KkQ36/dynamic-thread-pool/tree/20241022-get-thread-param](https://github.com/KkQ36/dynamic-thread-pool/tree/20241022-get-thread-param)
- 分支：`20241022-get-thread-param`
>[!info] dynamic-thread-pool-starter
```
├── dynamic-thread-pool-starter
│   ├── pom.xml
│   └── src
│       ├── main
│       │   ├── java
│       │   │   └── com
│       │   │       └── ryan
│       │   │           └── sdk
│       │   │               ├── config
│       │   │               │   ├── DynamicThreadPoolAutoConfig.java
│       │   │               │   └── DynamicThreadPoolAutoProperties.java
│       │   │               ├── domain
│       │   │               ├── registry
│       │   │               └── trigger
│       │   └── resources
│       │       └── META-INF
│       │           └── spring.factories
│       └── test
│           └── java
```

>[!info] dynamic-thread-pool-test
```
├── dynamic-thread-pool-test
│   ├── pom.xml
│   └── src
│       ├── main
│       │   ├── java
│       │   │   └── com
│       │   │       └── ryan
│       │   │           ├── Main80.java
│       │   │           └── config
│       │   │               ├── ThreadPoolConfig.java
│       │   │               └── ThreadPoolConfigProperties.java
│       │   └── resources
│       │       ├── application-dev.yml
│       │       └── application.yml
│       └── test
│           └── java
│               └── com
│                   └── ryan
│                       └── TestApi.java
└── pom.xml
```

# 要点记录
## 实现原理
要实现一个动态线程池，并不是说要去重写一个线程池的代码；Java 自带的线程池 `ThreadPoolExecutor` 已经提供了运行时配置的功能，具体来说，是提供了这样一些 `public` 的 `setter` 方法：
![[Pasted image 20241022090116.png]]
但是运行时的线程池监控是没有提供一个很好的实现方式的，所以，即使提供了运行时修改配置的功能，但如何配置？何时配置却成了问题。
动态线程池要提供的正是这样的功能：对线程池状态的观察 以及 便捷的线程池配置。

JDK 允许线程池使用方通过 ThreadPoolExecutor 的实例来动态设置线程池的核心策略，以 setCorePoolSize 为方法例，在运行期线程池使用方调用此方法设置 corePoolSize 之后，线程池会直接覆盖原来的corePoolSize 值，并且基于当前值和原始值的比较结果采取不同的处理策略。
对于当前值小于当前工作线程数的情况，说明有多余的 worker 线程，此时会向当前 idle 的 worker 线程发起中断请求以实现回收，多余的 worker 在下次 idel 的时候也会被回收；对于当前值大于原始值且当前队列中有待执行任务，则线程池会创建新的 worker 线程来执行队列任务，setCorePoolSize 等方法的具体流程如下：
[[🍗【Java】线程池的动态修改]]
## SpringBoot 自动配置
为了让 SpringBoot 在启动的时候可以自动装配我们的配置类，需要做这样配置：
>[!info] resources.META-INF.spring.factories
```java
org.springframework.boot.autoconfigure.EnableAutoConfiguration=com.ryan.sdk.config.DynamicThreadPoolAutoConfig
```
如果需要配置多个自动配置类的话，可以采用这样的方式
```java
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
	com.ryan.sdk.config.DynamicThreadPoolAutoConfig,\
	com.example.config.AnotherAutoConfig
```
在 Spring Boot 3.0 及更高版本中，`org.springframework.boot.autoconfigure.AutoConfiguration.imports` 文件是用来替代 spring.factories 文件中 EnableAutoConfiguration 条目的。它用于指定需要自动配置的类列表。
这个文件的格式非常简单，每行一个类名。例如，在 `mybatis-spring-boot-autoconfigure-3.0.3.jar` 中：
```java
org.mybatis.spring.boot.autoconfigure.MybatisLanguageDriverAutoConfiguration  
org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration
```
# 核心代码
>[!info] com.ryan.sdk.config.DynamicThreadPoolAutoConfig
>这就是上面配置的自动装配类，这里 DynamicThreadPollService 还没有实现，所以这个方法只是简单的返回一个字符串
```java
@Slf4j  
@Configuration  
@EnableConfigurationProperties(DynamicThreadPoolAutoProperties.class)  
public class DynamicThreadPoolAutoConfig {  
    @Bean("dynamicThreadPollService")  
    public String dynamicThreadPollService(ApplicationContext applicationContext) {  
        String applicationName = applicationContext.getEnvironment().getProperty("spring.application.name");  
        if (StringUtils.isBlank(applicationName)) {  
            applicationName = "缺省的";  
            log.warn("动态线程池，启动提示。SpringBoot 应用未配置 spring.application.name 无法获取到应用名称！");  
        }  
        log.info("动态线程池，启动提示。当前应用名称：{}", applicationName);  
        Map<String, ThreadPoolExecutor> threadPoolExecutorMap = applicationContext.getBeansOfType(ThreadPoolExecutor.class);  
        // 获取缓存数据，设置本地线程池配置  
        Set<String> threadPoolKeys = threadPoolExecutorMap.keySet();  
        for (String threadPoolKey : threadPoolKeys) {  
            ThreadPoolExecutor threadPoolExecutor = threadPoolExecutorMap.get(threadPoolKey);  
            log.info("pool key: {}, core pool size = {}", threadPoolKey, threadPoolExecutor.getCorePoolSize());  
            log.info("pool key: {}, max pool size = {}", threadPoolKey, threadPoolExecutor.getMaximumPoolSize());  
        }  
        return "";  
    }  
}
```
具体获取程序中所有线程池的方法是通过 ApplicationContext 提供的通过类型获取 Bean 的方法
```java
<T> Map<String, T> getBeansOfType(@Nullable Class<T> type) throws BeansException;
```
我们引入这个包，然后构建 ThreadPoolExecutor 即可：
>[!info] com.ryan.config.ThreadPoolConfig
> test 项目中的 Config 方法
```java
@Configuration  
@EnableConfigurationProperties(ThreadPoolConfigProperties.class)  
public class ThreadPoolConfig {  
  
    @Bean("threadPoolExecutor01")  
    public ThreadPoolExecutor threadPoolExecutor01(ThreadPoolConfigProperties properties) {  
        // 实例化策略  
        RejectedExecutionHandler handler;  
        switch (properties.getPolicy()){  
            case "AbortPolicy":  
                handler = new ThreadPoolExecutor.AbortPolicy();  
                break;  
            case "DiscardPolicy":  
                handler = new ThreadPoolExecutor.DiscardPolicy();  
                break;  
            case "DiscardOldestPolicy":  
                handler = new ThreadPoolExecutor.DiscardOldestPolicy();  
                break;  
            case "CallerRunsPolicy":  
                handler = new ThreadPoolExecutor.CallerRunsPolicy();  
                break;  
            default:  
                handler = new ThreadPoolExecutor.AbortPolicy();  
                break;  
        }  
  
        // 创建线程池  
        return new ThreadPoolExecutor(properties.getCorePoolSize(),  
                properties.getMaxPoolSize(),  
                properties.getKeepAliveTime(),  
                TimeUnit.SECONDS,  
                new LinkedBlockingQueue<>(properties.getBlockQueueSize()),  
                Executors.defaultThreadFactory(),  
                handler);  
    }  
  
    @Bean("threadPoolExecutor02")  
    public ThreadPoolExecutor threadPoolExecutor02(ThreadPoolConfigProperties properties) {  
        // 实例化策略  
        RejectedExecutionHandler handler;  
        switch (properties.getPolicy()){  
            case "AbortPolicy":  
                handler = new ThreadPoolExecutor.AbortPolicy();  
                break;  
            case "DiscardPolicy":  
                handler = new ThreadPoolExecutor.DiscardPolicy();  
                break;  
            case "DiscardOldestPolicy":  
                handler = new ThreadPoolExecutor.DiscardOldestPolicy();  
                break;  
            case "CallerRunsPolicy":  
                handler = new ThreadPoolExecutor.CallerRunsPolicy();  
                break;  
            default:  
                handler = new ThreadPoolExecutor.AbortPolicy();  
                break;  
        }  
  
        // 创建线程池  
        return new ThreadPoolExecutor(properties.getCorePoolSize(),  
                properties.getMaxPoolSize(),  
                properties.getKeepAliveTime(),  
                TimeUnit.SECONDS,  
                new LinkedBlockingQueue<>(properties.getBlockQueueSize()),  
                Executors.defaultThreadFactory(),  
                handler);  
    }  
  
}
```
# 测试
直接启动 test 程序，观察输出即可：
```java
2024-10-22T10:35:22.647+08:00  INFO 82454 --- [  restartedMain] c.r.s.c.DynamicThreadPoolAutoConfig      : 动态线程池，启动提示。当前应用名称：dynamic-thread-pool-test-app
2024-10-22T10:35:22.648+08:00  INFO 82454 --- [  restartedMain] c.r.s.c.DynamicThreadPoolAutoConfig      : pool key: threadPoolExecutor01, core pool size = 20
2024-10-22T10:35:22.648+08:00  INFO 82454 --- [  restartedMain] c.r.s.c.DynamicThreadPoolAutoConfig      : pool key: threadPoolExecutor01, max pool size = 50
2024-10-22T10:35:22.648+08:00  INFO 82454 --- [  restartedMain] c.r.s.c.DynamicThreadPoolAutoConfig      : pool key: threadPoolExecutor02, core pool size = 20
2024-10-22T10:35:22.648+08:00  INFO 82454 --- [  restartedMain] c.r.s.c.DynamicThreadPoolAutoConfig      : pool key: threadPoolExecutor02, max pool size = 50
```

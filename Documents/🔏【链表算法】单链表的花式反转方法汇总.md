# 翻转整个单链表
力扣第 206 题「[反转链表](https://leetcode.cn/problems/reverse-linked-list)」就是这个问题；给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。
```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```
可以采用迭代的方式来翻转链表，
![[翻转链表]]
这里需要记录三个节点，分别记录当前节点、前一个节点、下一个节点。
在翻转的时候，只需要将当前节点指向前一个节点，然后移动到下一个节点继续进行这样的操作即可。
```java
class Solution {
    public ListNode reverseList(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode pre, cur, nxt;
        pre = null; cur = head;
        while (cur != null) {
            nxt = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nxt;
        }
        return pre;
    }
}
```

可以将链表认为是一个特殊的二叉树，如果希望倒序输出链表的值，可以采用后序遍历的方式，本题就可以借鉴这样的思路：
```java
class Solution {
    ListNode newHead;
    public ListNode reverseList(ListNode head) {
        if (head == null) return head;
        ListNode node = reversal(head);
        node.next = null;
        return newHead;
    }
    public ListNode reversal(ListNode node) {
        if (node.next == null) {
            newHead = node;
            return node;
        } 
        ListNode next = reversal(node.next);
        pre.next = node;
        return node;
    }
}
```
不断的获取下一个节点，在返回后让它指向本节点，然后将当前节点返回，继续进行递归操作。
# 翻转链表的前 N 个节点
这次我们实现一个这样的函数：
```java
// 将链表的前 n 个节点反转（n <= 链表长度）
ListNode reverseN(ListNode head, int n)
```
比如说对于下图链表，执行 `reverseN(head, 3)`：
![[Pasted image 20241021193136.png|600]]
```java
ListNode reverseN(ListNode head, int n) {
    if (head == null || head.next == null) {
        return head;
    }
    ListNode pre, cur, nxt;
    pre = null; cur = head; nxt = head.next;
    while (n > 0) {
        cur.next = pre;
        pre = cur;
        cur = nxt;
        if (nxt != null) {
            nxt = nxt.next;
        }
        n--;
    }
    // 此时的 cur 是第 n + 1 个节点，head 是反转后的尾结点
    head.next = cur;
    // 此时的 pre 是反转后的头结点
    return pre;
}
```
# 翻转链表的一部分节点
对应力扣第 92 题，「[反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/description/)」，第一种就是借助上面翻转前 N 个链表的方法。
找到需要反转的链表组的前一个节点，对需要反转的链表组反转，然后将前一个节点指向反转完成的节点即可：
```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        ListNode dummy = new ListNode();
        dummy.next = head;
        int len = right - left + 1; // 需要反转的节点个数
        ListNode before = dummy;
        // 定位需要反转的节点的前一个节点
        for (int i = 0; i < left - 1; i++) {
            before = before.next;
        }
        before.next = reverseN(before.next, len);
        return dummy.next;
    }
    ListNode reverseN(ListNode head, int n) {
        if (head == null || head.next == null) return head;
        ListNode pre, cur, nxt;
        pre = null; cur = head; nxt = head.next;
        while (n > 0) {
            cur.next = pre;
            pre = cur;
            cur = nxt;
            if (nxt != null) {
                nxt = nxt.next;
            }
            n--;
        }
        // 此时的 cur 是第 n + 1 个节点，head 是反转后的尾结点
        head.next = cur;
        // 此时的 pre 是反转后的头结点
        return pre;
    }
}
```

其实本题的思路就是，找到需要反转范围的前一个节点 和 后一个节点，反转这部分的链表，将前一个节点指向 pre，将第一个节点指向后一个节点即可。
```java
class Solution {
    public ListNode reverseBetween(ListNode head, int left, int right) {
        if (left == right) return head;
        int len = right - left + 1; // 需要反转的节点个数
        ListNode dummy = new ListNode();
        dummy.next = head;
         // 第一个节点
        ListNode first = dummy;
        // 前一个节点
        ListNode before = dummy;
        // 定位两个特殊节点
        while (left != 0) {
            if (left == 1) before = first;
            first = first.next;
            left--;
        }
        ListNode pre = null;
        ListNode cur = first;
        ListNode next = first.next
        // 正常执行反转逻辑
        while (len != 0) {
            next = cur.next;
            cur.next = pre;
            pre = cur;
            cur = next;
            len--;
        }
        first.next = next;
        before.next = pre;
        return dummy.next;
    }

}
```

# K 个一组反转链表
对应力扣第 25 题，「[K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group/submissions/574577084/)」
给你链表的头节点 `head` ，每 `k` 个节点一组进行翻转，请你返回修改后的链表。
`k` 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 `k` 的整数倍，那么请将最后剩余的节点保持原有顺序。
你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。
```
输入：head = [1,2,3,4,5], k = 2
输出：[2,1,4,3,5]
```
本题天然适合递归求值，这里定义递归函数的返回值为 k 个一组翻转链表之后的头节点。
从开头开始，首先检测是否含有 k 个节点，如果没有，直接返回当前节点。
如果有，就从开头到第 k 个节点的内容，然后继续递归：
```java
class Solution {
    ListNode head = null;
    public ListNode reverseKGroup(ListNode head, int k) {
        if (head == null) return null;
        // 区间 [a, b) 包含 k 个待反转元素
        ListNode a, b;
        a = b = head;
        for (int i = 0; i < k; i++) {
            // 不足 k 个，不需要反转了
            if (b == null) return head;
            b = b.next;
        }
        // 反转前 k 个元素
        ListNode newHead = reverseN(a, k);
        a.next = reverseKGroup(b, k);
        return newHead;
    }

    // 反转前 N 个节点的函数
    ListNode reverseN(ListNode head, int n) {
        if (head == null || head.next == null) return head;
        ListNode pre, cur, nxt;
        pre = null; cur = head; nxt = head.next;
        while (n > 0) {
            cur.next = pre;
            pre = cur;
            cur = nxt;
            if (nxt != null) {
                nxt = nxt.next;
            }
            n--;
        }
        head.next = cur;
        return pre;
    }
}
```
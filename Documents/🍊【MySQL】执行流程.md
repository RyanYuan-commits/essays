### 1 MySQL 架构说明
MySQL 的架构共分为两层：「Server 层」和「存储引擎层」：
- Server 层负责 **建立连接、分析和执行 SQL**。MySQL 大多数的核心功能模块都在这实现，主要包括连接器，查询缓存、解析器、预处理器、优化器、执行器等。所有的内置函数，如日期、时间、数学和加密函数等和所有跨存储引擎的功能，如存储过程、触发器、视图等都在 Server 层实现。
- 存储引擎层负责**数据的存储和提取**。支持 InnoDB、MyISAM、Memory 等多个存储引擎，不同的存储引擎共用一个 Server 层。从 MySQL 5.5 版本开始， InnoDB 成为了 MySQL 的默认存储引擎。常说的索引数据结构，就是由存储引擎层实现的，不同的存储引擎支持的索引类型也不相同，比如 InnoDB 支持索引类型是 B+树 ，且是默认使用，也就是说在数据表中创建的主键索引和二级索引默认使用的是 B+ 树索引。
### 2 SQL 语句执行流程
![[MySQL 执行流程.png#pic_center|1000]]
#### 2.1 建立连接 - 连接器
##### 基本流程
1. **建立连接**：如果你在 Linux 操作系统里要使用 MySQL，那你第一步肯定是要先连接 MySQL 服务，然后才能执行 SQL 语句，连接的过程需要先经过 TCP 三次握手。
2. **验证密码**：完成连接建立后，连接器就要开始验证你的用户名和密码，如果用户名或密码不对，会收到 "Access denied for user" 的错误。
3. **存储权限**：如果用户密码都没有问题，连接器就会获取该用户的权限，然后保存起来，后续该用户在此连接里的任何操作，都会基于连接开始时读到的权限进行权限逻辑的判断。所以，如果一个用户已经建立了连接，即使管理员中途修改了该用户的权限，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。
##### 查看连接数
可以通过执行 `show processlist` 命令进行查看 MySQL 被多少个客户端连接。
 ![[show processlist 命令.png|700]]
比如上图的显示结果，共有两个用户名为 root 的用户连接了 MySQL 服务，其中 id 为 6 的用户的 Command 列的状态为 `Sleep` ；
这意味着该用户连接完 MySQL 服务就没有再执行过任何命令，也就是说这是一个空闲的连接，并且空闲的时长是 736 秒（ Time 列）。
##### 空闲连接的处理
MySQL 定义了最大空闲时长，由 `wait_timeout` 参数控制的，默认值是 8 小时，如果空闲连接超过了这个时间，连接器就会自动将它断开。
![[MySQL 空闲连接存活时间.png|500]]

当然，我们自己也可以手动断开空闲的连接，使用的是 kill connection + id 的命令。
```sh
mysql> kill connection +6;
Query OK, 0 rows affected (0.00 sec)
```
##### 连接数限制
MySQL 服务支持的最大连接数由 max_connections 参数控制，超过这个值，系统就会拒绝接下来的连接请求，并提示 “Too many connections”。
```sh
mysql> show variables like 'max_connections';
+-----------------+-------+
| Variable_name   | Value |
+-----------------+-------+
| max_connections | 151   |
+-----------------+-------+
1 row in set (0.00 sec)
```
#### 2.2 查询缓存
连接完成后，客户端就可以向 MySQL 服务发送 SQL 语句了，MySQL 收到 SQL 后，会解析出语句的第一个字段，看看是什么类型的语句，如果发现是 select 语句，MySQL 就会先去「查询缓存」里查找缓存数据，看看之前有没有执行过这一条命令；
这个查询缓存是以 key-value 形式保存在内存中的，key 为 SQL 查询语句，value 为 SQL 语句查询的结果。
查询的语句命中查询缓存，会直接返回 value 给客户端，但是，**查询缓存的命中率很低**，因为只要一个表有更新操作，那么这个表的查询缓存就会被清空。在 MySQL 8.0 版本直接将查询缓存删掉了，也就是说 MySQL 8.0 开始，执行一条 SQL 查询语句，不会再走到查询缓存这个阶段了，对于 MySQL 8.0 之前的版本，如果想关闭查询缓存，我们可以通过将参数 query_cache_type 设置成 DEMAND。
#### 2.3 解析 SQL - 解析器
在正式执行 SQL 查询语句之前，会先解析语句，这个工作交由「解析器」来完成。
解析器会做如下两件事情：
#### 2.3.1 词法分析
MySQL 会根据你输入的字符串识别出关键字出来；
例如，SQL语句 select username from userinfo；在分析之后，会得到 4 个 Token，其中有 2 个 Keyword，分别为 select 和 from：
   ![[MySQL 词法分析案例.png|500]]
#### 2.3.2 语法分析
根据词法分析的结果，语法解析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法；
如果没问题就会构建出 SQL 语法树，这样方便后面模块获取 SQL 类型、表名、字段名、 where 条件等等。
   ![[SQL 语法树案例.png|800]]
如果我们输入的 SQL 语句语法不对，就会在解析器这个阶段报错；
但是表不存在或者字段不存在，并不是在解析器里做的，解析器只负责检查语法和构建语法树，但是不会去查表或者字段存不存在。
#### 2.4 执行 SQL
经过解析器后，接着就要进入执行 SQL 查询语句的流程了，每条`SELECT` 查询语句流程主要可以分为三个阶段：
##### 预处理阶段
1. 检查 SQL 查询语句中的表或者字段是否存在；
2. 将 select \* 中的 \* 符号，扩展为表上的所有列；
当查询的表格不存在的时候，就会在 prepare 阶段报错
##### 优化阶段
经过预处理阶段后，还需要为 SQL 查询语句先制定一个执行计划，这个工作交由「优化器」来完成的。
优化器主要负责 **将 SQL 查询语句的执行方案确定下来**，比如在表里面有多个索引的时候，优化器会基于查询成本的考虑，来决定选择使用哪个索引。
要想知道优化器选择了哪个索引，我们可以在查询语句最前面加个 `explain` 命令，这样就会输出这条 SQL 语句的执行计划，然后执行计划中的 key 就表示执行过程中使用了哪个索引；
![[EXPLAIN 语句结果.png|900]]
#### 2.5 执行器
经历完优化器后，就确定了执行方案，接下来 MySQL 就真正开始执行语句了，这个工作是由「执行器」完成的。在执行的过程中，执行器就会和存储引擎交互了，交互是以记录为单位的。
#二叉树 
# 二叉树的层序遍历方式
先来看一下力扣第 102 题「[二叉树的层序遍历](https://leetcode.cn/problems/binary-tree-level-order-traversal/)」：
- 给你二叉树的根节点 `root` ，返回其节点值的 **层序遍历** 。 （即逐层地，从左到右访问所有节点）。
---
解决这个题目有两个方法：迭代法和递归法：
迭代法的思路是将元素放到一个队列中，初始的 len 为 1，每次从这个队列中取出元素，将其左右子树填充进去；
当遍历 len 个元素的时候，说明本层已经遍历完了，继续到下一层做相同的操作：
```java
class Solution {
    public List<List<Integer>> levelOrder(TreeNode root) {
        Queue<TreeNode> queue = new LinkedList<>();
        List<List<Integer>> res = new ArrayList<>();
        queue.add(root);
        int len = 1; //记录每一层有多少元素
        while (!queue.isEmpty()) {
            res.add(new ArrayList<>());
            for (int i = 0; i < len; i++) {
                TreeNode node = queue.poll();
                if (node != null) {
		            // 将左右子树填充到队列中
                    res.get(res.size() - 1).add(node.val);
                    queue.add(node.left);
                    queue.add(node.right);
                }
            }
            // 更新 len
            len = queue.size();
        }
        res.remove(res.size() - 1);
        return res;
    }
}
```
迭代法的思路是记录一个 deep，每层元素的 deep 值是相同的，然后将数据填充到 `res.get(deep)` 中。
因为遍历的顺序是先左后右，所以得到的每层元素的顺序也会是从左到右的，无需调整。
```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> levelOrder(TreeNode root) {
        reversal(root, 0);
        return res;
    }
    public void reversal(TreeNode node, int deep) {
        if (node == null) return;
        if (res.size() <= deep) res.add(new ArrayList<>());
        
        res.get(deep).add(node.val);
        
        reversal(node.left, deep + 1);
        reversal(node.right, deep + 1);
    }
}
```
# 二叉树的右视图
力扣第 199 题，「[二叉树的右视图](https://leetcode.cn/problems/binary-tree-right-side-view/description/?envType=study-plan-v2&envId=top-interview-150)」：
给定一个二叉树的 **根节点** `root`，想象自己站在它的右侧，按照从顶部到底部的顺序，返回从右侧所能看到的节点值。
![[二叉树的右视图案例一图片.png|300]]
- **输入:** [1,2,3,null,5,null,4]
- **输出:** [1,3,4]
---
上面提到，递归层序遍历的顺序是从左到右的顺序，按照这样的顺序，最右边的元素一定是本层最后一个被遍历到的。
按照这个思路，我们在层序遍历的过程中，不断更新某一层元素的值，就能得到最终的序列：
```java
class Solution {
    List<Integer> res = new ArrayList<>();
    public List<Integer> rightSideView(TreeNode root) {
        reversal(root, 0);
        return res;
    }
    void reversal (TreeNode node, int deep) {
        if (node == null) return;
        if (deep >= res.size()) res.add(0);
	    // 不断切换，最终一个就是结果
        res.set(deep, node.val);
        reversal(node.left, deep + 1);
        reversal(node.right, deep + 1);
    }
}
```
同样，如果先右后左的话，也是最右边的元素首先被遍历到：
```java
class Solution {
    List<Integer> res = new ArrayList<>();
    public List<Integer> rightSideView(TreeNode root) {
        reversal(root, 0);
        return res;
    }
    void reversal (TreeNode node, int deep) {
        if (node == null) return;
        if (deep >= res.size()) res.add(1000);
        if (res.get(deep) == 1000) res.set(deep, node.val);
        reversal(node.right, deep + 1);
        reversal(node.left, deep + 1);
    }
}
```
# 二叉树的层平均值
力扣第 637 题，「[二叉树的层平均值](https://leetcode.cn/problems/average-of-levels-in-binary-tree/)」
- 给定一个非空二叉树的根节点 `root` , 以数组的形式返回每一层节点的平均值。
---
层序遍历的同时记录一下元素总和和元素个数就可以，但需要注意一下越界的情况。
```java
class Solution {
    Map<Integer, long[]> map = new HashMap<>();
    public List<Double> averageOfLevels(TreeNode root) {
        reversal(root, 0);
        int len = map.size();
        List<Double> res = new ArrayList<>();
        for (int i = 0; i < len; i++) {
            long total = map.get(i)[0];
            long num = map.get(i)[1];
            res.add((double)total / num);
        }
        return res;
    }
    void reversal(TreeNode node, int deep) {
        if (node == null) return;
        if (map.size() <= deep) map.put(deep, new long[2]);
        map.get(deep)[0] += node.val;
        map.get(deep)[1] += 1;
        reversal(node.left, deep + 1);
        reversal(node.right, deep + 1);
    }
}
```
# 锯齿形层序遍历
力扣第 103 题，「[二叉树的锯齿形层序遍历](https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/)」：
- 给你二叉树的根节点 `root` ，返回其节点值的 **锯齿形层序遍历** 。（即先从左往右，再从右往左进行下一层遍历，以此类推，层与层之间交替进行）。
---
在遍历过程中，当遍历到奇数层级的时候，插入的时候从开头插入；当遍历到偶数层级的时候，插入的时候从结尾插入。
```java
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        if (root == null) return res;
        LinkedList<TreeNode> queue = new LinkedList<>();
        queue.push(root);
        int len = 1;
        int deep = 0;
    

        while (!queue.isEmpty()) {
            LinkedList<Integer> tmp = new LinkedList<>();
            for (int i = 0; i < len; i++) {
                TreeNode node = queue.poll();
                if (node != null) {
                    if (deep % 2 == 0) tmp.addLast(node.val);
                    else tmp.addFirst(node.val);
                    queue.add(node.left);
                    queue.add(node.right);
                }
            }
            if(!tmp.isEmpty()) res.add(tmp);
            deep += 1;
            len = queue.size();
        }

        return res;
    }
}
```
# N 叉树的层序遍历
力扣第 429 题，「[N 叉树的层序遍历](https://leetcode.cn/problems/n-ary-tree-level-order-traversal/)」：
- 给定一个 N 叉树，返回其节点值的_层序遍历_。（即从左到右，逐层遍历）。树的序列化输入是用层序遍历，每组子节点都由 null 值分隔（参见示例）。
- ---
直接套用二叉树的层序遍历的模板即可：
```java
class Solution {
    List<List<Integer>> res = new ArrayList<>();
    public List<List<Integer>> levelOrder(Node root) {
        reversal(root, 0);
        return res;
    }
    void reversal(Node node, int deep) {
        if (node == null) return;
        if (res.size() <= deep) res.add(new ArrayList<>());
        res.get(deep).add(node.val);
        for (Node child : node.children) {
            reversal(child, deep + 1);
        }
    }
}
```
# 找到每层的最大元素
力扣第 515 题，「[在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)」
给定一棵二叉树的根节点 `root` ，请找出该二叉树中每一层的最大值。
![[在每个树行中找最大值图例.png|400]]
- **输入:** root = [1,3,2,5,3,null,9]
- **输出:** [1,3,9]
---
在遍历过程中比较元素大小即可
```java
class Solution {
    List<Integer> res = new ArrayList<>();
    public List<Integer> largestValues(TreeNode root) {
        reversal(root, 0);
        return res;
    }
    void reversal(TreeNode node, int deep) {
        if (node == null) return;
        if (res.size() <= deep) res.add(Integer.MIN_VALUE);
        int old = res.get(deep);
        res.set(deep, Math.max(old, node.val));
        reversal(node.left, deep + 1);
        reversal(node.right, deep + 1);
    }
}
```
# 本层的下一个节点
力扣第 117 题，「 [填充每个节点的下一个右侧节点指针 II](https://leetcode.cn/problems/populating-next-right-pointers-in-each-node-ii/)」
给定一个二叉树：
```c
struct Node {
  int val;
  Node *left;
  Node *right;
  Node *next;
}
```
填充它的每个 next 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 next 指针设置为 `NULL` 。初始状态下，所有 next 指针都被设置为 `NULL` 。
![[填充每个节点的下一个右侧节点指针 II 例题一.png|600]]
- **输入**：root = [1,2,3,4,5,null,7]
- **输出**：[1,#,2,3,#,4,5,7,#]
---
之前提到过，因为采用的是 左中右 的遍历顺序，所以每层的节点一定是按照本层的顺序被遍历到的。
所以就可以使用一个 list 存储每层的一个节点，然后遍历到本层的下一个节点的时候，将 list 中本层的节点指向该节点，然后替换即可。
```java
class Solution {
    List<Node> list = new ArrayList<>();
    public Node connect(Node root) {
        reversal(root, 0);
        return root;
    }

    void reversal(Node node, int deep) {
        if (node == null) return;
        if (list.size() <= deep) list.add(null);

        Node pre;
        if ((pre = list.get(deep)) != null) pre.next = node;
        list.set(deep, node);

        reversal(node.left, deep + 1);
        reversal(node.right, deep + 1);
    }
}
```
# 涉及题目
- 「[螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)」
- 「[螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/description/)」
# 螺旋矩阵
先来看力扣第 54 题 「[螺旋矩阵](https://leetcode.cn/problems/spiral-matrix/)」：
给你一个 `m` 行 `n` 列的矩阵 `matrix` ，请按照 **顺时针螺旋顺序** ，返回矩阵中的所有元素。
![[螺旋矩阵案例.png]]
```
输入：matrix = [[1,2,3],[4,5,6],[7,8,9]]
输出：[1,2,3,6,9,8,7,4,5]
```
![[螺旋矩阵示例 2.png]]
```
输入：matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
输出：[1,2,3,4,8,12,11,10,9,5,6,7]
```
这一类题目的思路其实是比较简单的，就是按照题目中给的顺序，右、下、左、上来螺旋遍历数组。
但是本题的难点类似于「[二分查找](https://leetcode.cn/problems/binary-search/)」：**边界条件很难控制**；且写出来的算法有可能少遍历了一些元素。
![[螺旋矩阵思路.png|600]]
这里舍弃那些复用循环变量的思路，我们就用四个变量来写一个相对复杂但是通用又好理解的思路：
- 解题的核心思路是按照右、下、左、上的顺序遍历数组
- 在遍历的过程中，使用长和宽两个边来圈定还未遍历的范围，初始的高对应的边为：`(0, m - 1)`，长对应的边为：`(0, n - 1)`，所以我们给出以下的四个变量：
```java
// 高边
int u = 0, d = m - 1;  
// 长边
int l = 0, r = n - 1;
```
对于这样的题目，在遍历之前，我们就需要明确一些边界条件：
- 比如先向右遍历再向下遍历的时候，中间这个转折点（例如示例 1 中的 3 节点），是在向右遍历的时候遍历，也就是转折点都在转折之前去完成。
- 循环的终止条件是什么？
按照题意来说，终止的条件就是：没有未遍历的元素的时候，翻译成代码就是我们限定的范围变为了 0，也就是这样的情况：
```java
u > d || l > r
```
此时就可以结束遍历，这里先给出代码。
```java
class Solution {
    public List<Integer> spiralOrder(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        int u = 0, d = m - 1;
        int l = 0, r = n - 1;
        List<Integer> res = new LinkedList<>();
        while (true) {
		    // 在最上层，从左向右遍历
            for (int i = l; i <= r; i++) res.add(matrix[u][i]);
            if (++u > d) break;

			// 在最右边，从上向下遍历
            for (int i = u; i <= d; i++) res.add(matrix[i][r]);
            if (--r < l) break;
            
			// 在最下层，从右向左遍历
            for (int i = r; i >= l; i--) res.add(matrix[d][i]);
            if (--d < u) break;
            
			// 在最左边，从下向上遍历
            for (int i = d; i >= u; i--) res.add(matrix[i][l]);
            if (++l > r) break;
        }
        return res;
    }
}
```
这里详细举例解释一下这两个部分：
```java
// 在最上层，从左向右遍历
for (int i = l; i <= r; i++) res.add(matrix[u][i]);
if (++u > d) break;

// 在最右边，从上向下遍历
for (int i = u; i <= d; i++) res.add(matrix[i][r]);
if (--r < l) break;
```
首先从最上层开始，从左向右遍历，也就是不断更新列索引；循环变量 i 的 范围是 `[l, r]`，也就对应了上面说的转折点在转折之前遍历。
当完成了最高层的遍历，更新剩余未遍历的元素，此时的高边就应该更新为 `[u + 1, d]`，如果发现 `u + 1 > d` 说明没有剩余的元素了，结束循环输出结果。
在最右边，从上向下遍历的时候，起点是从`u + 1`，没有去遍历之前的转折点。
# 螺旋矩阵 II
对应力扣第 59 题「[螺旋矩阵 II](https://leetcode.cn/problems/spiral-matrix-ii/description/)」：
给你一个正整数 `n` ，生成一个包含 `1` 到 `n2` 所有元素，且元素按顺时针顺序螺旋排列的 `n x n` 正方形矩阵 `matrix` 。
```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```
与上一题不同的是，本题需要我们自己生成矩阵，但本质还是矩阵的螺旋遍历，修改一下上面的代码即可。
```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] res = new int[n][n];
        int u = 0, d = n - 1;
        int l = 0, r = n - 1;
        int temp = 1;
        while (true) {
            // 上层，从左往右
            for (int i = l; i <= r; i++) res[u][i] = temp++;
            if (++u > d) break;

            // 右边，从上往下
            for (int i = u; i <= d; i++) res[i][r] = temp++;
            if (--r < l) break;

            // 底层，从右向左
            for (int i = r; i >= l; i--) res[d][i] = temp++;
            if (--d < u) break;

            // 左边，从下往上
            for (int i = d; i >= u; i--) res[i][l] = temp++;
            if (++l > r) break;
        }
        return res;
    }
}
```

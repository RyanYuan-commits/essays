### 1 为什么需要 undo log？
#### 1.1 事务的自动开启
在执行一条增删改操作时，虽然没有输入 `begin` 开启事务和 `commit` 提交事务，但 MySQL 还是会隐式的开启事务来执行这样的语句，执行完就自动的提交事务，这样就保证了执行完一条修改数据的语句的时候，我们可以立刻在数据库表中看到结果。通过下面的 SQL 语句，我们可以配置全局或者当前会话的配置值。
```sql
-- 查看当前 session 的 auto commit 配置
SELECT @@autocommit;

-- 查看全局 auto commit 的配置
SELECT @@global.autocommit;
```
这些值也是可以被修改的，在 MySQL 中，上面两个配置的默认值都是 1（开启），可以通过下面的语句将其设置为关闭：
```sql
-- 1 开启 0 关闭
SET autocommit = 0;
SET GLOBAL autocommit = 0;
```
将其设置为关闭的时候，我们再执行 SQL 语句就不会主动提交了，而是将所有的 SQL 语句放在一个事务中，需要手动执行 `COMMIT` 语句来提交：
```sql
SET autocommit = 0;
SELECT @@autocommit;
INSERT INTO user_0 VALUES (3, 'jack', 21);
COMMIT;
```
当执行完 INSERT 语句，库里是这样的，而在执行了 COMMIT 语句后，`jack` 才会被真正的添加进去
![[autocommit 演示.png]]
#### 1.2 事务回滚
我们都知道事务可以 **回滚**，那回滚的数据是从哪里来的呢？

如果在一整个事务中，所操控的数据之间互相完全不依赖，那么处理起来相对简单。我们可以在提交事务后，将这些内容刷入数据库。
但作为设计者来说，这种情况只是需要考虑的情况之一。在绝大多数情况下，整个事务操作的数据之间是相互依赖的。
为了实现这种数据相互依赖情况下的事务处理效果，同时保证正确的回退，MySQL 的设计者采用了这样的方法：在事务执行过程中，根据对数据的修改操作动态地记录回滚时需要的信息到回滚日志（通常是 undo log）里。当需要回滚的时候，从日志中取出这些信息，然后进行反向操作即可（这里的反向操作是指将数据恢复到事务开始之前的状态，例如，如果一个操作是将某个字段的值从 A 改为 B，那么反向操作就是将该字段的值从 B 改回 A）。

同时在每个事务中，有一个属性存储着对其有效的最早的 undo log，当发现某些日志不被需要就会将它们删除。
#### 1.3 支持多版本并发控制
另外，undo log 还有一个作用，与 Read View 配合实现多版本并发控制 MVCC。
对于「读提交」和「可重复读」隔离级别的事务来说，快照读是通过 MVCC 来实现的，它们的区别在于创建 Read View 的时机不同：
- 「读提交」隔离级别是在每个 select 都会生成一个新的 Read View，也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。
- 「可重复读」隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View，这样就保证了在事务期间读到的数据都是事务启动前的记录。
=> [[🐿️【MySQL】隔离级别底层原理]]
这两个隔离级别实现是通过「事务的 Read View 里的字段」和「记录中的两个隐藏列（`trx_id` 和 `roll_pointer`）」的比对，如果不满足可见行，就会顺着 `undo log` 版本链里找到满足其可见性的记录，从而控制并发事务访问同一个记录时的行为，这就叫 MVCC（多版本并发控制）。
### 2 数据结构
一条记录的每一次更新操作产生的 `undo log` 格式都有一个 `roll_pointer` 指针和一个 `trx_id` 事务id：
- 通过 `trx_id` 可以知道该记录是被哪个事务修改的
- 通过 `roll_pointer` 指针可以将这些 undo log 串成一个链表，这个链表就被称为版本链
![[undo log 的格式.png|800]]
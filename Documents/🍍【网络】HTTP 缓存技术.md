对于一些具有重复性的 HTTP 请求，比如每次请求得到的数据都一样的，我们可以把这对「请求-响应」的数据都 **缓存在本地**，那么下次就直接读取本地的数据，不必在通过网络获取服务器的响应了，这样的话 HTTP 的性能肯定肉眼可见的提升。
HTTP 缓存有两种实现方式，分别是强制缓存和协商缓存。
### 1 强制缓存
#### 1.1 Expires
强制缓存是只要浏览器判断缓存没有过期，就直接使用浏览器的本地缓存，决定权在浏览器。
![[强制缓存.png|700]]
如果服务器希望浏览器使用强制缓存，就会在返回头里面带上一个名为 `Expires` 的参数，这个参数表示缓存的过期绝对时间。
但是有可能出现时区不一致的情况，导致浏览器和服务端的时钟并不一致，此时会给协商缓存带来很大的麻烦；
为了解决这个问题，同时提供更精细的缓存控制，`Cache-Control` 诞生了。
#### 1.2 Cache-Control
`Cache-Control` 有这些选项：
- `max-age`：缓存过期的相对时间，单位是秒
- `no-cache`：不使用强缓存
- `no-store`：禁止缓存
- `private`：只有浏览器可以缓存
- `public`：浏览器、服务器、代理服务器都可以缓存
如果 Cache-Control 和 Expires 同时存在，Cache-Control 的优先级更高。
### 2 协商缓存
#### 2.1 案例
当我们在浏览器使用开发者工具的时候，你可能会看到过某些请求的响应码是 `304`，这个是告诉浏览器可以使用本地缓存的资源，通常这种通过服务端告知客户端是否可以使用缓存的方式被称为协商缓存。
![[协商缓存过程.png|800]]
上图就是一个协商缓存的过程，所以协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。
#### 2.2 Last-Modified + If-Modified-Since
第一种实现方式是通过请求头中的 `If-Modified-Since` 字段与响应头部中的 `Last-Modified` 字段实现，这两个字段的意思是：
- 响应头部中的 `Last-Modified`：标示这个响应资源的最后修改时间；
- 请求头部中的 `If-Modified-Since`：当资源过期了，发现响应头中具有 Last-Modified 声明，则再次发起请求的时候带上 Last-Modified 的时间，服务器收到请求后发现有 `If-Modified-Since` 则与被请求资源的最后修改时间进行对比（Last-Modified），如果最后修改时间较新（大），说明资源又被改过，则返回最新资源，HTTP 200 OK；如果最后修改时间较旧（小），说明资源无新修改，响应 HTTP 304 走缓存。
#### 2.3 If-None-Match + Etag
第二种实现方式是通过请求头部中的 `If-None-Match` 字段与响应头部中的 `ETag` 字段，这两个字段的意思是：
- 响应头部中 `Etag`：唯一标识响应资源；
- 请求头部中的 `If-None-Match`：当资源过期时，浏览器发现响应头里有 Etag，则再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 的值。服务器收到请求后进行比对，如果资源没有变化返回 304，如果资源变化了返回 200。

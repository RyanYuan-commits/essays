建造者模式所完成的内容就是通过将多个简单对象通过一步步的组装构建出一个复杂对象的过程。
## 使用场景
- **创建复杂对象**：当需要创建的对象结构复杂，包含多个部分，且这些部分的构建过程较为繁琐时，建造者模式非常适用。例如，创建一个汽车对象，汽车包含发动机、轮胎、车身、内饰等多个部分，每个部分的构建都有不同的细节和配置，使用建造者模式可以将这些构建过程分离，使得代码更加清晰和易于维护。
- **对象构建步骤多样化**：如果一个对象的构建步骤可以有多种不同的组合方式，使用建造者模式可以灵活地控制这些步骤。比如，在游戏开发中创建一个角色，角色的创建可以有不同的顺序和配置，如先设置角色的外观，再选择技能，或者先确定技能，再设计外观等，建造者模式可以方便地实现这些不同的构建顺序。
- **需要隐藏对象创建细节**：在一些情况下，客户端只需要得到一个完整的对象，而不关心对象的具体创建过程。建造者模式可以将对象的创建细节封装在建造者类中，客户端只需要与指挥者进行交互，从而隐藏了复杂的创建逻辑。
## 案例代码
```java
// 产品类：电脑
class Computer {
    private String cpu;
    private String memory;
    private String hardDisk;

    public void setCpu(String cpu) {
        this.cpu = cpu;
    }

    public void setMemory(String memory) {
        this.memory = memory;
    }

    public void setHardDisk(String hardDisk) {
        this.hardDisk = hardDisk;
    }

    @Override
    public String toString() {
        return "Computer{" +
                "cpu='" + cpu + '\'' +
                ", memory='" + memory + '\'' +
                ", hardDisk='" + hardDisk + '\'' +
                '}';
    }
}

// 抽象建造者
abstract class ComputerBuilder {
    protected Computer computer;

    public Computer getComputer() {
        return computer;
    }

    public void createNewComputer() {
        computer = new Computer();
    }

    public abstract void buildCpu();
    public abstract void buildMemory();
    public abstract void buildHardDisk();
}

// 具体建造者：普通电脑建造者
class NormalComputerBuilder extends ComputerBuilder {
    @Override
    public void buildCpu() {
        computer.setCpu("Intel Core i5");
    }

    @Override
    public void buildMemory() {
        computer.setMemory("8GB");
    }

    @Override
    public void buildHardDisk() {
        computer.setHardDisk("512GB SSD");
    }
}

// 具体建造者：高端电脑建造者
class HighEndComputerBuilder extends ComputerBuilder {
    @Override
    public void buildCpu() {
        computer.setCpu("Intel Core i9");
    }

   
	@Override
    public void buildMemory() {
        computer.setMemory("32GB");
    }

    @Override
    public void buildHardDisk() {
        computer.setHardDisk("1TB NVMe SSD");
    }
}

// 指挥者
class ComputerDirector {
    private ComputerBuilder computerBuilder;

    public ComputerDirector(ComputerBuilder computerBuilder) {
        this.computerBuilder = computerBuilder;
    }

    public Computer constructComputer() {
        computerBuilder.createNewComputer();
        computerBuilder.buildCpu();
        computerBuilder.buildMemory();
        computerBuilder.buildHardDisk();
        return computerBuilder.getComputer();
    }
}

// 测试类
public class BuilderPatternDemo {
    public static void main(String[] args) {
        // 创建普通电脑
        ComputerBuilder normalBuilder = new NormalComputerBuilder();
        ComputerDirector normalDirector = new ComputerDirector(normalBuilder);
        Computer normalComputer = normalDirector.constructComputer();
        System.out.println("普通电脑配置：" + normalComputer);

        // 创建高端电脑
        ComputerBuilder highEndBuilder = new HighEndComputerBuilder();
        ComputerDirector highEndDirector = new ComputerDirector(highEndBuilder);
        Computer highEndComputer = highEndDirector.constructComputer();
        System.out.println("高端电脑配置：" + highEndComputer);
    }
}
```
## 模式分析
### 优点
- **封装性好**：将对象的创建过程封装在建造者类中，客户端不需要了解具体的构建细节，提高了代码的封装性和可维护性。
- **构建过程灵活**：可以通过不同的具体建造者来实现不同的构建方式，满足多样化的需求。同时，指挥者可以灵活地控制构建步骤的顺序。
- **代码复用性高**：各个具体建造者可以复用相同的构建逻辑，避免了代码的重复。
### 缺点
- **类的数量增加**：引入了多个建造者类和指挥者类，会导致类的数量增多，增加了系统的复杂度。
- **适用范围有限**：建造者模式适用于创建复杂对象，如果对象的构建过程简单，使用建造者模式会显得过于繁琐。

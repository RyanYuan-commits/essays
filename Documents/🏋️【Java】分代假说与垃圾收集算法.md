## 1 分代收集理论

### 1.1 分代假说

当前商业虚拟机的垃圾收集器，大多数都遵循了“分代收集”的理论进行设计，分代收集名为理论，实质是一套符合大多数程序运行实际情况的经验法则，它建立在两个分代假说之上：

1. **弱分代假说**：绝大多数对象都是朝生夕灭的。
2. **强分代假说**：熬过越多次垃圾收集过程的对象就越难以消亡。

这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄分配到不同的区域之中存储；

在 Java 堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域，因而也就有了 “Minor GC”、“Major GC”、“Full GC” 这样的回收类型的划分。

把分代收集理论具体放到现在的商用 Java 虚拟机里，设计者一般至少会把 Java 堆划分为新生代和老年代两个区域。在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放；
### 1.2 跨代引用假说

但是分代也不只是简单的划分一下内存区域，它至少存在一个明显的困难，对象不是孤立的，对象之间会存在 **跨代引用**。

假如要现在进行一次只局限于新生代区域内的收集(Minor GC)，但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的 GC Roots 之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。

为了解决这个问题，就需要对分代收集理论添加第三条经验法则：**跨代引用假说：跨代引用相对于同代引用来说仅占极少数。**

这个假说可以由分代假说推出，因为如果新生代和老年代对象之间存在应用的话，必然会导致新生代对象长久的存活，最终他也会被放置到老年代。

依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构（记忆集），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。

=> [[🥐【Java】记忆集与卡表]]

此后当发生 Minor GC 时，只有包含了跨代引用的小块内存里的对象才会被加入到 GC Roots 进行扫描。虽然这种方法需要在对象改变引用关系(如将自己或者某个属性赋值)时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。
## 2 GC 的分类

根据收集的部分不同，GC 可以分为部分收集和整堆收集两种。
### 2.1 部分收集

指目标不是完整收集整个Java堆的垃圾收集，其中又分为:

- 新生代收集：指目标只是新生代的垃圾收集，当 Eden 区空间不足的时候触发。
- 老年代收集：指目标只是老年代的垃圾收集。目前只有CMS收集器会有单独收集老年代的行为，当新生代晋升失败时触发，另外请注意 Major GC 这个说法现在有点混淆，在不同资料上常有不同所指，需按上下文区分到底是指老年代的收集还是整堆收集。
- 混合收集：指目标是收集整个新生代以及部分老年代的垃圾收集。目前只有 G1 收集器会有这种行为。
### 2.2 整堆收集

收集整个Java堆和方法区的垃圾收，触发时机有：

- 程序主动调用 `System.gc()`，**建议执行**；
- 方法区或者老年代空间不足；
- 并发收集器（例如 CMS、G1）发生并发失败。
## 3 垃圾收集算法

### 3.1 标记-清除算法

最早出现也是最基础的垃圾收集算法是“标记-清除”(Mark-Sweep)算法，后续的收集算法大多都是以标记-清除算法为基础，对其缺点进行改进而得到的。标记清除算法在1960年由Lisp之父 John McCarthy所提出。
执行方式：如它的名字一样，算法分为“标记”和“清除”两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。
![[标记-清除算法示意图.png|800]]
它的主要缺点有两个：
1. 效率不太稳定，如果 Java 堆区中有大量对象需要回收的话，此时必须进行大量的标记和清楚的动作。
2. 内存空间碎片化问题，标记清除后会产生大量的，不连续的内存碎片；可能会导致在运行过程中需要分配内存给较大的对象的时候，无法找到合适的位置而不得不提前触发另一次垃圾回收动作。
### 3.2 标记-复制算法

标记-复制算法常被简称为复制算法。为了解决标记-清除算法面对大量可回收对象时执行效率低的问题，1969年Fenichel提出了一种称为“半区复制”(Semispace Copying)的垃圾收集算法。
它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，进行一次标记，然后就将标记存活的对象复制到另外一块内存，然后再把已使用过的内存空间一次清理掉。
![[标记-复制算法示意图.png|800]]
这种内存收集方式同样存在缺陷：
- 当存活的对象过多的时候，会产生大量的内存复制开销。
- 可用的内存比原来缩小了一半。
但是他解决了标记清除算法的==大量可回收对象效率低==、==空间碎片化==这两个问题问题：
- 对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象；
- 每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。
### 3.3 标记-整理算法

标记-复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费 50% 的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都 100% 存活的极端情况，**所以在老年代一般不能直接选用这种算法**。
针对老年代对象的存亡特征，1974 年 Edward Lueders 提出了另外一种有针对性的“标记-整理”(Mark-Compact)算法，其中的标记过程仍然与“ 标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是**让所有存活的对象都向内存空间一端移动**，然后直接清理掉边界以外的内存。
![[标记-整理算法示意图.png|800]]
## 4 关于是否移动对象的讨论
### 4.1 是否移动对象均存在弊端

如果移动存活对象，尤其是在**老年代这种每次回收都有大量对象存活区域**，移动存活对象并更新所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行，这就更加让使用者不得不小心翼翼地权衡其弊端了，像这样的停顿被最初的虚拟机设计者形象地描述为 “Stop The World”。
但如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。譬如通过 “分区空闲分配链表” 来解决内存分配问题。内存的访问是用户程序最频繁的操作，甚至都没有之一，假如在这个环节上增加了额外的负担，势必会直接影响应用程序的吞吐量。
基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂；
### 4.2 方法取舍

从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。
HotSpot 虚拟机里面关注吞吐量的 Parallel Scavenge 收集器是基于标记 - 整理算法的，而关注延迟的 CMS 收集器则是基于标记-清除算法的，这也从侧面印证这点。
$$吞吐量 = \frac{运行用户代码的时间}{运行用户代码的时间 + 运行垃圾收集的时间}$$
虽然标记清除算法减少了垃圾收集的时间，但是由于内存碎片的元素，会使得程序更快的进入垃圾收集阶段，所以整体来看，系统的吞吐量是下降的。
另外，还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。基于标记-清除算法的 CMS 收集器面临空间碎片过多时采用的就是这种处理办法。

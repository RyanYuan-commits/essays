# 删除有序数组的重复项 II
力扣第 80 题「[删除有序数组的重复项 II](https://leetcode.cn/problems/remove-duplicates-from-sorted-array-ii/description/)」：
给你一个有序数组 `nums` ，请你 **原地** 删除重复出现的元素，使得出现次数超过两次的元素**只出现两次** ，返回删除后数组的新长度。
不要使用额外的数组空间，你必须在 **原地修改输入数组** 并在使用 O(1) 额外空间的条件下完成。
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int slow = 0;
        int pre = nums[0];
        int time = 0;
        for (int i = 0; i < nums.length; i++) {
            if (time != 2 && nums[i] == pre) {
                nums[slow++] = nums[i];
                time++;
            } else if (nums[i] != pre) {
                nums[slow++] = nums[i];
                time = 1;
            }
            pre = nums[i];
        }
        return slow;
    }
}
```

# 验证回文串
力扣第 125 题「[验证回文串](https://leetcode.cn/problems/valid-palindrome/description/)」
如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后，短语正着读和反着读都一样。则可以认为该短语是一个 **回文串** 。字母和数字都属于字母数字字符。
```
输入: s = "A man, a plan, a canal: Panama"
输出：true
解释："amanaplanacanalpanama" 是回文串。
```
需要注意一下数字的情况和大小写的转化：
```java
class Solution {
    public boolean isPalindrome(String s) {
        char[] arr = s.toCharArray();
        int left = 0;
        int right = arr.length - 1;
        while (left < right) {
            while (!isValid(arr[left]) && left < right) left++;
            while (!isValid(arr[right]) && left < right) right--;
            if (!isEquals(arr[left], arr[right])) return false;
            left++;
            right--;
        }
        return true;
    }
    boolean isEquals(char a, char b) {
        if (a >= 'A' && a <= 'Z') a = (char)(a + 32);
        if (b >= 'A' && b <= 'Z') b = (char)(b + 32);
        return a == b;
        
    }
    boolean isValid(char c) { 
        return c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' || c >= '0' &&  c<= '9';
    }
}
```
# 颜色分类
对应力扣第 75 题「[颜色分类](https://leetcode.cn/problems/sort-colors/description/)」:给定一个包含红色、白色和蓝色、共 `n` 个元素的数组 `nums` ，**原地** 对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。使用整数 `0`  `1`  `2` 分别表示红色、白色和蓝色。
```
输入：nums = [2,0,2,1,1,0]
输出：[0,0,1,1,2,2]
```
假如将本题的颜色个数调整成两个，只有 `0` 和 `1` 的话，只需要一个指针慢指针 `slow`  和一个快指针 `fast`，快指针每次遍历到 `1` 的时候，就与慢指针 **交换**，最终就会将 `0` 放到一边，`1` 放到另一边。
在上面这个例子中，`slow` 圈定了这样一个范围 `[0, slow)` 这个范围内都是 1。
本题就可以借鉴一下这个思路，使用 `[0, p0)` 来圈定 0 的范围，使用 `(p2, nums.length - 1]` 来圈定 `1` 的范围。
```java
class Solution {
    public void sortColors(int[] nums) {
        // 注意区间的开闭，初始化时区间内应该没有元素
        // 所以我们定义 [0，p0) 是元素 0 的区间，(p2, nums.length - 1] 是 2 的区间
        int p0 = 0, p2 = nums.length - 1;
        int p = 0;
        // 由于 p2 是开区间，所以 p <= p2
        while (p <= p2) {
            if (nums[p] == 0) {
                swap(nums, p0, p);
                p0++;
            } else if (nums[p] == 2) {
                swap(nums, p2, p);
                p2--;
            } else if (nums[p] == 1) {
                p++;
            }
            // 因为小于 p0 都是 0，所以 p 不要小于 p0
            if (p < p0) {
                p = p0;
            }
        }
    }
    private void swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }
}
```
# 合并两个有序数组
力扣第 88 题，「[合并两个有序数组](https://leetcode.cn/problems/merge-sorted-array/)」：给你两个按 **非递减顺序** 排列的整数数组 `nums1` 和 `nums2`，另有两个整数 `m` 和 `n` ，分别表示 `nums1` 和 `nums2` 中的元素数目。请你 **合并** `nums2` 到 `nums1` 中，使合并后的数组同样按 **非递减顺序** 排列。
因为需要填充数据的部分在 `nums1` 的末尾，需要采用倒序遍历的方式，从大到小开始填充。
```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int len = nums1.length;
        int p1 = m - 1;
        int p2 = nums2.length - 1;
        int cursor = len - 1;
    
        for (; cursor >= 0 && p1 >= 0 && p2 >= 0; cursor--) {
            if (nums1[p1] > nums2[p2]) {
                nums1[cursor] = nums1[p1--];
            } else {
                nums1[cursor] = nums2[p2--];
            }
        }
        while (p1 >= 0) nums1[cursor--] = nums1[p1--];
        while (p2 >= 0) nums1[cursor--] = nums2[p2--];
    }
}
```
# 将矩阵按对角线排序
力扣第 1329 题「[https://leetcode.cn/problems/sort-the-matrix-diagonally/description/](https://leetcode.cn/problems/sort-the-matrix-diagonally/description/)」
**矩阵对角线** 是一条从矩阵最上面行或者最左侧列中的某个元素开始的对角线，沿右下方向一直到矩阵末尾的元素。
例如，矩阵 `mat` 有 `6` 行 `3` 列，从 `mat[2][0]` 开始的 **矩阵对角线** 将会经过 `mat[2][0]`、`mat[3][1]` 和 `mat[4][2]` 。
```
输入：mat = [[3,3,1,1],[2,2,1,2],[1,1,1,2]]
输出：[[1,1,1,1],[1,2,2,2],[1,2,3,3]]
```
思路就是遍历每个对角线的起点，然后将这些元素排序后，原封不动的填回去就可以了。
对角线的起点也就是第一行和第一列的元素：
```java
class Solution {
    public int[][] diagonalSort(int[][] mat) {
        int m = mat.length;
        int n = mat[0].length;
        
        // 遍历对角线的起点，也就是第一行和第一列
        // 1. 第一行，包含 (0, 0)
        for (int i = 0; i < mat[0].length; i++) {
            sortAndFill(0, i, mat);
        }
        // 2. 第一列，包含 (0, 0)
        for (int i = 1; i < mat.length; i++) {
            sortAndFill(i, 0, mat);
        }

        return mat;
    }

    List<Integer> list = new ArrayList<>();
    void sortAndFill(int sX, int sY, int[][] mat) {
        int x = sX, y = sY;
        while (x < mat.length && y < mat[0].length) {
            list.add(mat[x++][y++]);
        }
        Collections.sort(list);
        x = sX;
        y = sY;
        while (x < mat.length && y < mat[0].length) {
            mat[x++][y++] = list.remove(0);
        }
    }
}
```
# 二维网格迁移
给你一个 `m` 行 `n` 列的二维网格 `grid` 和一个整数 `k`。你需要将 `grid` 迁移 `k` 次。
每次「迁移」操作将会引发下述活动：
- 位于 `grid[i][j]`（`j < n - 1`）的元素将会移动到 `grid[i][j + 1]`。
- 位于 `grid[i][n - 1]` 的元素将会移动到 `grid[i + 1][0]`。
- 位于 `grid[m - 1][n - 1]` 的元素将会移动到 `grid[0][0]`。
请你返回 `k` 次迁移操作后最终得到的 **二维网格**。
这道题有些像力扣第 151 题「[颠倒字符串中的单词](https://leetcode.cn/problems/reverse-words-in-a-string)」，151 题让你把句子中的所有单词位置翻转，解法思路是先翻转整个句子，然后逐一翻转每个单词。
这道题是同样的思路：你可以写一个 `get` 方法和 `set` 方法把二维数组抽象成一维数组，然后题目就变成了让你将一个一维的数组平移 `k` 位，相当于把前 `mn - k` 个元素的位置和后 `k` 个元素的位置对调，也可以先把整个数组翻转，再分别翻转前 `mn - k` 个元素和后 `k` 个元素，得到的结果就是题目想要的。
```java
class Solution {
    public List<List<Integer>> shiftGrid(int[][] grid, int k) {
        int m = grid.length;
        int n = grid[0].length;
        List<List<Integer>> res = new ArrayList<>();

        // 整体翻转
        reverse(0 ,0, m - 1, n - 1, grid);
        
        // 翻转前 k 个元素
        k = k % (m * n);
        int[] xy = new int[]{0, -1};
        for (int i = 0; i < k; i++) {
            getNext(xy, grid);
        }
        reverse(0, 0, xy[0], xy[1], grid);
        getNext(xy, grid);
        
        // 反转 k + 1 到末尾的元素
        reverse(xy[0], xy[1], m - 1, n - 1, grid);
        for (int i = 0; i < grid.length; i++) {
            List<Integer> list = new ArrayList<>();
            for (int j = 0; j < grid[0].length; j++) {
                list.add(grid[i][j]);
            }
            res.add(list);
        }
        return res;
    }
    void getNext(int[] xy, int[][] grid) {
        xy[1] = xy[1] + 1;
        if (xy[1] >= grid[0].length) {
            xy[1] = 0;
            xy[0] = xy[0] + 1;
        }
    }
    void reverse(int leftX, int leftY, int rightX, int rightY, int[][] grid) {
        while ((leftX < rightX) || (leftX == rightX && leftY < rightY)) {
            int temp = grid[leftX][leftY];
            grid[leftX][leftY] = grid[rightX][rightY];
            grid[rightX][rightY] = temp;

            leftY = leftY + 1;
            if (leftY == grid[0].length) {
                leftY = 0;
                leftX = leftX + 1;
            }

            rightY = rightY - 1;
            if (rightY == -1) {
                rightY = grid[0].length - 1;
                rightX = rightX - 1;
            }
        }
    }

}
```
# 转置矩阵
给你一个二维整数数组 `matrix`， 返回 `matrix` 的 **转置矩阵** 。矩阵的 **转置** 是指将矩阵的主对角线翻转，交换矩阵的行索引与列索引。
```java
class Solution {
    public int[][] transpose(int[][] matrix) {
       int m = matrix.length;
       int n = matrix[0].length;
       int[][] res = new int[n][m];
       for (int i = 0; i < matrix.length; i++) {
        for (int j = 0; j < matrix[0].length; j++) {
            res[j][i] = matrix[i][j];
        }
       }
       return res;
    }
}
```
# 最长公共前缀
编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 `""`。
```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        StringBuilder res = new StringBuilder();
        for (int i = 0; ; i++) {
            String str = strs[0];
            if (i >= str.length()) return res.toString();
            char c = str.charAt(i);
            for (int j = 1; j < strs.length; j++) {
                String s = strs[j];
                if (i >= s.length()) return res.toString();
                if (s.charAt(i) != c) return res.toString();
            }
            res.append(c);
        } 
    }
}
```
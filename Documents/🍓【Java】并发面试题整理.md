### 线程状态如何流转？
![[线程状态如何流转.png|900]]

### sleep 和 wait 有什么区别？
两者都可以暂停线程的执行​
- **类的不同**：sleep 是 Thread线程类的静态方法，wait() 是 Object类的方法。​
- **是否释放锁**：sleep 不释放锁；wait 释放锁。​
- **用途不同**：Wait 通常被用于线程间交互/通信，sleep 通常被用于暂停执行。​
- **用法不同**：wait 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 notify 或者 notifyAll 方法。sleep 方法执行完成后，线程会自动苏醒。或者可以使用wait(long timeout)超时后线程会自动苏醒。
### 为什么线程通信的方法 wait(), notify()和 notifyAll()被定义在 Object 类里？
wait、notify、notifyAll 被设计在 Object 类中的原因是，Java 提供的锁是对象级的而不是线程级的，每个对象都有个锁，而线程是可以获得这个对象的， 因此线程需要等待某些锁，那么只要调用对象中的wait()方法便可以了。​

有的人会说，既然是线程放弃对象锁，那也可以把 wait 定义在 Thread 类里面啊，新定义的线程继承于 Thread 类，也不需要重新定义 wait 方法的实现。然而，这样做有一个非常大的问题，一个线程完全可以持有很多锁，你一个线程放弃锁的时候，到底要放弃哪个锁？当然了，这种设计并不是不能实现，只是管理起来更加复杂。
### 为什么 wait, notify 和 notifyAll 必须在同步方法或者同步块中被调用？
当一个线程需要调用对象的 wait 方法的时候，这个线程必须拥有该对象的锁，接着它就会释放这个对象锁并进入等待状态直到其他线程调用这个对象上的 notify 方法。同样的，当一个线程需要调用对象的 notify 方法时，也会先获取到对象的锁，然后执行 notify, 最后再释放这个对象的锁，以便其他在等待的线程就可以得到这个对象锁。
由于所有的这些方法都需要线程持有对象的锁，这样就只能通过同步来实现，所以他们只能在同步方法或者同步块中被调用。
### 一个线程运行时发生异常会怎样？
如果异常没有被捕获该线程将会停止执行。​
Thread.UncaughtExceptionHandler 是用于处理未捕获异常造成线程突然中断情况的一个内嵌接口。当一个未捕获异常将造成线程中断的时候，JVM 会使用 Thread.getUncaughtExceptionHandler() 来查询线程的 UncaughtExceptionHandler 并将线程和异常作为参数传递给 handler 的 uncaughtException() 方法进行处理。
### 1 引入分布式共识算法的背景
#### 1.1 如何提高更大规模数据的读写性能？
1. **更好的机器**：属于纵向扩展，在系统设计上没什么工作量，但压力来到了硬件设计这一侧；机器的性能达到一定程度之后，想要更进一步的梯度会陡然提升，这就好比一门满分 100 分的考试，从 90 分提升到 98 分的难度可能大于从 60 分提升到 90 分的难度。
2. **更多的机器**：属于横向扩展，理论上，在网络环境绝对理想化的情况下，这种方式可以做到上不封顶，设立更多的机器，既可以在系统安全性方面做到状态数据的容灾备份，也能够在处理请求流程中通过负载均衡的方式减轻单个节点压力，从而提高系统的整体上限.

关于第（2）点需要补充说明的点是，在现实中并没有绝对理想的网络环境，集群节点数量也有一个合适的范围，一味地增加节点不加以约束，最终只会导致集群内部的网络请求行为反过来成为系统瓶颈点.

#### 1.2 分布式的优势和问题
分布式优势主要体现在两点：
- **数据备份**：避免单点故障导致数据丢失或服务不可用；
- **负载均衡**：多个节点共同分担总任务，那么理论上单个节点的任务强度与节点数量成反比.

随之而来的是，横向分布式所带来的问题：
- 如何保证不同节点之间，数据的一致性？（这里又可以进一步分为最终一致性和即时一次性）
- 如何保证分布式系统的秩序？（能正常提供服务，不出现脑裂、崩溃、耗时过长等问题）

以上问题的根本原因在于网络的不确定性。

单节点的优势在于，单机的内存和磁盘读写操作都是很稳定的，要么成功，要么失败，则耗时很短。

而分布式引入了网络交互的流程，网络请求的耗时远远慢于单机操作，且网络请求可能存在丢失、超时、乱序等异常情况，这些情形都需要被妥善处理，从而导致系统整体复杂度的上升。

#### 1.3 [[🍀 CAP 定理]]

#### 1.4 分布式一致性共识算法
分布式一致性共识算法指的是在分布式系统中，使得所有节点对同一份数据的认知能够**达成共识**的算法。

在尽可能少的牺牲 C 的基础上，将 A 提高到尽可能高的水平。

Raft 算法就是一个分布式一致性共识算法
- 在可用性 A 方面，Raft 算法能够保证当前分布式系统半数及以上节点存活的条件下，系统是可用的；同时请求耗时取决于多数节点的下限，而不取决于所有节点的下限。
- 在一致性 C 方面，Raft 能够保证数据的最终一致性，在工程化实践中，可以在 Raft 算法上稍作修改，来达到数据的即时一致性，从而进一步做到强 C。

### 2 Raft 算法核心概念
#### 2.1 术语表
节点的三种角色：
- Leader 领导者：集群的首脑，负责发起“提议“ 和 ”提交“被多数派认可的决断。
- Follower 跟随者：需要对 Leader 的 “提议”、“提交” 以及 Candidate 的 “竞选“ 进行响应。
- Candidate 竞选者：是一种处于竞选流程中的**临时状态**，根据多数派投票的结果会切为 leader 或 follower 的稳定态。

一致性：
- Final Consistency 最终一致性：中强一致性. 对于写请求，服务端保证最终一定能提供出正确的结果，但需要同步时间. 同步期间，可能被读到不一致的老数据。
- Immediate Consistency 即时一次性：强一致性. 服务端要求做到写入立即可读。

两阶段提交：
- Proposal 提议：两阶段提交的第一个阶段，Leader 向所有节点发起日志同步请求的过程。
- Commit 提交：两阶段提交的第二个阶段，Leader 认可一笔写请求已经被系统采纳的动作。
- Apply 应用：指的是将预写日志记录内记录的写操作应用到状态机的过程.

其他术语：
- Write Ahead Log 预写日志：记录写请求明细的日志.（单指 raft 算法下狭义的预写日志）。
- State Machine 状态机：节点内存储数据的介质。
- Index 日志索引：日志在预写日志数组中的位置.
- Term 任期：任期是用于标识 leader 更迭的概念. 每个任期内至多只允许有一个 leader。
- Brain Split 脑裂：同一任期内，集群出现两个 leader，导致秩序崩盘。

#### 2.2 多数派原则
![[多数派原则.png|center|300]]
多数派，指的是一个群体的数量达到总数的一半以上。

多数派原则指的是，系统的决断无需全员参与,多数派达成的共识即可视为整个系统的答复。

多数派原则贯穿 Raft 算法的始终，不管是数据同步，还是领导者的选举，只要是达到多数派的认可就可以采纳结果，同时处于拒绝态或者未响应态的少数派在随后感知到该决断已经被集群多数派认同后，最终也会执行采纳。

多数派原则是提高分布式系统可用性 A 的关键. 对于整个系统而言，执行一项操作要求全员共同响应以实现强 C 的保证是过于苛刻的，因为我们无法保证所有节点都能健康运作，这种底线思维是研发人员所必须具备的素养. 但是倘若退而求其次，只要多数派达成共识即可正常决断和响应，这样下限就提高很多了. 由全员响应进化为多数派共识，这将把一种底线思维下的随机性问题进化为一个数学期望问题.

多数派原则大大提升了 A 的分数，那么接下来的讨论重点就在于，raft 算法如何在多数派这一框架下，达成 C 的要求.

#### 2.3 一主多从、读写分离
![[Raft-一主多从、读写分离.png|center|800]]

一主多从：Raft 算法下系统中的节点分为领导者 Leader 和跟随者 Follower 两类角色；
- Leader 拥有更广阔的视野，需要总览全局，领导一些日常事务的推进；
- Follower 职责相对简单但同样重要，因为这是一个基于多数派原则运作的民众团体，所有角色只要拧成一股绳，聚成了多数派，就能代表整个系统进行决断，甚至包括推翻 Leader。

读写分离：读操作可以由集群的任意节点提供服务；写操作统一需要由 Leader 收口处理
- Leader 需要向 Follower 同步写操作. 倘若 Follower 率先收到了来自客户端的写请求，也需要转发给 Leader 进行处理；
- 这种读写分离的机制，通过读操作的负载均衡提高了系统整体的吞吐量，也通过写操作的统一收口降低了共识算法的复杂度。

#### 2.4 状态机与预写日志
![[Raft-状态机与预写日志.png|center|600]]

状态机是**节点实际存储数据的容器**，写请求的最后一步是将结果写入状态机，而读请求也需要从状态机中获取数据进行响应。

预写日志（Write Ahead Log，简称 WAL）是通过日志的方式记录下 **每一笔写请求的明细**（例如 set x = 3），使得变更历史有迹可循。在 Raft 算法中，写请求会先组织成预写日志的形式添加到日志数组中，当一个日志（写请求）达到集群多数派的认可后，才能够被提交，将变更应用到状态机当中。

WAL 被设计用于解决前面提到的顺序一致性问题，即从机器收到两次 set 的顺序不一致，而导致从机器与主机器可能长久的保持不一致的问题。

预写日志记录在一个数组结构中，存储的是写请求的明细内容，在这样的机制下，只要保证预写日志数组中被允许应用到状态机日志的内容相同，就能够 **解决请求乱序的问题**。

#### 2.5 两阶段提交
![[Raft-两阶段提交.png|center|600]]
两阶段提交可以分别从单机和系统的两个维度进行解读.

从单机层面，一笔写请求会分为 **添加到预写日志** 和 **应用到状态机** 两个步骤，这是对两阶段提交的一种体现；

整个系统层面，两阶段提交的流程可拆解如下：
1. Leader 接收到来自 Client 的写请求
2. Leader 将写请求添加到 WAL 中，并向其他节点广播同步这个写请求，整个过程称为 “提议” Proposal。
3. Follower 节点根据自身的校验机制判断是否执行同步，如果执行同步也将写请求 **添加** 到 WAL 中，并向 Leader 返回 ACK。
4. 如果集群中半数的节点都将请求添加 WAL 中，那么 Leader 会 “**提交**” 这个请求，并给予 Client 请求成功的响应。
5. 其他节点在随后的时段中，会通过与 Leader 的交互（心跳或其他同步数据的请求）感知到这个“**提交**”动作，最终也在预写日志中提交这笔请求。
6. 被提交的预写日志具备了被应用到状态机的资格。但应用的时机取决于实现方式，倘若只追求最终一致性，可以选择异步应用；倘若追求立即一致性，则会要求 Leader 先应用到状态机，才能给予客户端 Ack。

上述流程中，第（2）步是提议阶段（Proposql），第（4）步是提交阶段（Commit），两者相加，构成了所谓的“两阶段提交”的流程。

这个过程遵循了多数派原则，第一阶段的 Proposal 让 Leader 有了群访 Proposal 收集民意的机会，当多数派达成共识，可以立即提交请求并响应客户端。

#### 2.6 领导者选举
Leader 是写请求的入口，如果出了问题，会导致整个集群不可写，Raft 中建立了一套完整的选举机制，倘若 Leader 宕机，会由 Follower 补位成为新的 Leader。

==Follower 如何感应到 Leader 挂了，从而主动补位？==
- Leader 需要定期向 Follower 发送心跳，证明自己仍然健在；
- 与之对应的，Follower 会建立一个心跳检测定时器，当超过指定时长未收到 Leader 的心跳，则认为 Leader 已死，Follower 会切换成 Candidate 发起竞选，尝试补位成为新的 Leader。

==什么样的 Follower 有资格称为 Leader？==
- Follower 成为 Candidate 后，会广播向所有节点拉票，
- 当投赞同票的节点数达到多数派的时候，该 Candidate 会胜任，成为新的 Leader。

#### 2.7 任期与日志索引
任期 Term，就像是朝代，集群由一个 Leader 切换到另一个 Leader 的过程称之为 “改朝换代”，此时对应的任期数会进行累加。

![[Raft-任期.png|center|600]]

每当一个 Candidate 发起一轮竞选时，会将当前 Term 在旧任期的基础上加 1，倘若胜任成为新的 Leader，这就将成为自己的 “国号”。但不是每个 Term 都有 Leader，因为可能在 Candidate 未胜出的前提下，Term 又进一步进行了累加，从而实现朝代的跨越。

节点中的预写日志存放在一个数组中，每则日志在数组中的位置称之为索引 Index，每一则预写日志会有两个核心的标识属性：
- Term：标志了这则日志是哪个任期时同步写入的；
- Index：标志了这则日志在预写日志数组的位置。

通过 Term + Index 可以定位到一则日志，并且可以保证 Term + Index 相同，其内容一定是 **完全一致** 的。

### 3 Raft 算法下的角色流转
#### 3.1 角色定义及切换
![[Raft-角色定义及切换.png|center|600]]

**Leader => Follower**：倘若 Leader 发现当前系统中出现了更大的任期，则会进行“禅让”，主动退位成 Follower，这里 Leader 发现更大任期的方式包括：
- 向 Follower 提交日志同步请求时,从 Follower 的响应参数中获得; 
- 收到了来自新任 Leader 的心跳或者同步日志请求；
- 收到了任期更大的 Candidate 的拉票请求。

**Follower => Candidate**：当 Follower 认为当前 Leader 已经宕机的时候，会将自身的状态切换为 Candidate：
- Leader 需要定期向 Follower 发送心跳，告知自己仍健在的消息。
- 倘若 Follower 超过一定时长没收到 Leader 心跳时，会将状态切换为 Candidate ，在当前任期的基础上加 1 作为竞选任期，发起竞选尝试补位。

**Candidate => Follower**：竞选失败或者竞选已经结束
- 多数派投了反对票；
- 竞选期间，收到了任期大于等于自身竞选任期的 Leader 传来的请求。

**Candidate => Leader**：Candidate 竞选成功
- 在竞选过程中，多数派投了赞成票

**Candidate => Candidate**：竞选超时，发起新一轮的竞选
- Candidate 的竞选流程有一个时间阈值. 倘若超时仍未形成有效结论（多数派赞同或拒绝），则会维持 Candidate 身份，将竞选任期加 一，发起新一轮竞选。

#### 3.2 Leader 领导者
![[Raft-Leader 领导者.png|center|800]]

Leader 是写请求的统一入口，在接收到来自客户端的写请求时，会开启“两阶段提交”的流程：
1. 广播 Proposal，向所有节点同步这一请求；
2. 当请求得到多数派的赞同后，才会提交这一请求.

Leader 还需要周期性地向集群中所有节点 **单向的** 发送自己的心跳，告知自己的健康状况，用途包括：
1. 让 Follower 重置心跳检测定时器，避免其切换成 Candidate 发起竞选；
2. 在心跳请求中携带上 Leader 最新已提交日志的标识 id（Term + Index），推动 Follower 更新日志提交进度。

#### 3.3 Follower 跟随者
![[Raft-Follower 跟随者.png|center|800]]

Follower 的职责包括如下几项：
1. 负责同步 Leader 传来的写请求，此时也有一个参与民主反馈的过程，倘若同步成功，会给予 Leader 正向反馈，当 Leader 的同步请求收到半数以上的认可时，会提交日志；
2. 通过接收 Leader 心跳的方式，获取到携带的 CommitIndex 信息，及时完成已被多数派认可的预写日志的提交，以推进其写入状态机的进度. 这一项相当于做到了数据的备份，也被读请求最终一致性提供了保证;
3. 负责为参与竞选 Candidate 的投票
4. 通过心跳检测定时器时时关注 Leader 的健康状态，当超时未收到心跳时，会切换为 Candidate 发起竞选.

#### 3.4 Candidate 候选人
![[Raft-Candidate 候选人.png|center|600]]
Candidate 是一个临时态，成为 Candidate 意味着此时正处于成与败的分叉路口，Candidate 有关的核心流程如下：
1. 倘若 Follower 切为 Candidate，会将当前任期加1，作为竞选任期；
2. 会将自身的一票投给自己；
3. 广播向所有节点拉票；
4. 倘若拉票请求超时前，得到多数派认可，则上位为 Leader；
5. 倘若拉票请求超时前，遭到多数派拒绝，则老实退回 Follower；
6. 倘若拉票请求超时前，收到了任期大于等于自身竞选任期的 Leader 的请求，则老实退回 Follower；
7. 倘若拉票请求超时，则竞选任期加 1，发起新一轮竞选拉票请求。

### 4 外部请求链路梳理
#### 4.1 Write 写请求
![[Raft-Write 写请求.png|center|600]]
1. 写操作需要由 Leader 统一收口. 倘若 Follower 接收到了写请求，则会告知客户端 Leader 的节点 ID，让客户端重新将写请求发送给 Leader 处理；
2. Leader 接收到写请求后，会先将请求抽象成一笔预写日志，追加到预写日志数组的末尾；
3. Leader 会广播向集群中所有节点发送同步这笔日志的请求，称之为第一阶段的“提议”；
4. Follower 将日志同步到本机的预写日志数组后，会给 Leader 回复一个“同步成功”的 ACK；
5. Leader 发现这笔请求对应的预写日志已经被集群中的多数派（包括自身）完成同步时，会 ”提交“ 该日志，并向客户端回复 “写请求成功” 的 ACK。

上面描述了一个最理想化的写流程链路，其中还存在几个场景需要进行补充：

==case 1：Leader 任期滞后：==
在第（4）步中，倘若 Follower 发现当前 Leader 的 Term 小于自己记录的最新任期，本着 ”前朝的剑不斩本朝官“ 的原则，Follower 会拒绝 Leader 的这次同步请求，并在响应中告知 Leader 当前最新的 Term；Leader 感知到新 Term 的存在后，也会识相地主动完成退位.

==case 2：Follower 日志滞后：==
同样在第（4）步中，此时虽然 Leader 的 Term 是最新的，但是在这笔最新同步日志之前， Follower 的预写日志数据还存在缺失的数据，此时 Follower 会拒绝 Leader 的同步请求；Leader 发现 Follower 响应的任期与自身相同却又拒绝同步，会递归尝试向 Follower 同步预写日志数组中的前一笔日志，直到补齐 Follower 缺失的全部日志后，流程则会回归到正常的轨道。
![[Raft-Follower 日志滞后.png|center|800]]

==case 3：Follower 日志”超前“.==
同样在第（4）步中，Leader 的 Term 是最新的，但是 Follower 在 Leader 最新同步日志的索引及其之后已存在日志，且日志内容还与当前 Leader 不一致. 此时 Follower 需要移除这部分”超前“的日志，然后同步 Leader 传送的日志，向当前在任 Leader 看齐。
![[Raft-Follower 日志”超前“.png|center|800]]

小结：case 2 和 case 3 的处理方式共同保证了，在 raft 算法下，各节点间预写日志数组的已提交部分无论在内容还是顺序上都是完全一致的.

==case 4：如何将最终一致性升级到即时一致性？==
标准的 Raft 算法模型中，在 C 方面只能做到”最终一致性“的语义. 倘若想要升级为”即时一致性“，就需要在写流程和读流程中都做些额外的处理。
在写流程第（5）步中，leader 不仅需要提交这笔写请求对应的预写日志，还需要确保将 **这笔日志应用到状态机** 中，才能给予客户端”请求成功“的 ACK，以此保证读 Leader 状态机时，能读取到最新的数据。

#### 4.2 Read 读操作
Raft 标准模型中，客户端的读请求可以被集群中的任意节点处理，最终会取状态机中的数据进行响应。
由于预写日志 + 二阶段提交 + 多数派原则的机制保证了被提交的日志具有”最终一致性“的语义，而只有被提交的日志才有资格被应用到状态机，因此状态机的数据也必然具有最终一致性，而无法保证即时一次性（Follower 和 Leader 之间的数据状态）。

如果要求读流程满足即时一次性的要求，则要做一些额外的处理：

##### AppliedIndex 校验
每次 Leader 处理写请求后，会把最晚一笔应用到状态机的日志索引 AppliedIndex 反馈给客户端。后续客户端和 Follower 交互时，会携带 AppliedIndex。

倘若 Follower 发现自身的 AppliedIndex 落后于客户端的 AppliedIndex，说明本机存在数据滞后，则拒绝这笔请求，由客户端发送到其他节点进行处理。

##### 强制读 Leader
Follower 收到读请求时，也统一转发给 Leader 处理。但是这样的弊端就是 Leader 的压力过大，其他 Follow 节点只沦为备份数据副本的配角。

同时，这种强制读主的方案还存在一个问题，就是领导者在处理读请求时，需要额外对自己做一次合法性身份证明，Leader 提供读服务时，需要额外向集群所有节点发起一轮广播，当得到多数派的认可，证明自己身份仍然合法时，才会对读请求进行响应。这是因为倘若当前网络出现分区情况，外界早已更换朝代，而 Leader 仍坐落于小分区中不知大清已亡，固执地认为自己是正统，那么此时提供的读服务就无法保证即时一致性，会退化为最终一致性。

这个 Leader 身份合法校验的问题只存在于读请求中而不影响写请求，这是因为 Leader 处理写流程时，在提议阶段就必须与外界通信，获取多数派的反馈.这个反馈的过程实际上就已经完成了对 Leader 身份合法性的校验。

### 5 内部请求链路梳理
本节侧重于讨论服务端内部不同角色的节点之间的交互流程，主要按照请求类型分类展开。

#### 5.1 日志同步请求
![[Raft-日志同步请求.png|center|800]]

当 Leader 节点接收到写请求的时候，需要向 Follower 发送 **日志同步请求** 来同步 WAL，属于 Proposal 阶段。

##### 请求参数
Leader 发送的请求参数包含如下部分：

| 字段名         | 说明                                                         |
| -------------- | ------------------------------------------------------------ |
| Term           | Leader 自身的任期；                                          |
| LeaderID       | Leader 节点的 ID，方便 Follower 后续转发写请求；             |
| LeaderCommit   | Leader 最新提交日志的 index，方便 Follower 同步数据进度；    |
| PrevLogIndex   | 前一条同步日志的 Index；                                     |
| PrevLogTerm    | 前一条日志的任期；                                           |
| Log[]          | 同步的日志，可能为多个，因为 Follower 可能滞后了多笔日志。   |

##### 请求终点
日志同步请求在 Leader 的处理情况有包括：
- Leader 收到了比自己任期更小的 Leader 的同步请求，拒绝这个同步请求，并回复自己的 Term；
- Leader 收到了比自己任期更到的 Leader 的同步请求，退位为 Follower，按照 Follower 来处理请求。

日志同步请求在 Follower 的处理情况有：
- 收到了比自己存储的 Term 更小的 Leader 的同步请求，拒绝，回复自己的任期；
- 如果 Follower 存在不一致的日志，删除多余的日志，同步 Leader 的日志直到与其保持一致；
- 倘若 Follower 存在日志滞后，则拒绝请求，让 Leader 重发更早的日志，直到补齐所有缺失。

日志同步请求在 Candidate 的处理情况有：
- 倘若发现 Leader 的 Term 大于自己的 Term，退回到 Follower 来处理请求；
- 如果 Leader 的任期小于自己，拒绝并返回自己的最新任期。

##### 响应参数
Follower 对日志同步的响应参数包含：
- Term：节点当前的任期
- Success：当前请求是否成功

##### Leader 后处理
1. 倘若多数派都完成了日志的同步，Leader 会提交这笔日志（Commit）
2. 倘若某个节点拒绝了同步请求，并回复了一个更新的任期，Leader 会退位为 Follower，并更新任期；
3. 倘若某个节点拒绝了同步请求，但回复了相同的任期，Leader 会递归发送前一条日志给该节点，直到其接受同步请求为止；
4. 倘若一个节点超时未给 Leader 回复，Leader 会重发这笔同步日志的请求。

#### 5.2 心跳&提交同步请求
![[Raft-心跳&提交同步请求.png|center|800]]
Leader 会周期性的发送心跳证明自己依旧健在，同时同步日志提交的进度，心跳请求是单向非阻塞的，Leader 发送心跳后无需等待其他节点的回复。

##### 请求参数
| 字段           | 说明                                      |
| ------------ | --------------------------------------- |
| Term         | 领导者的任期                                  |
| LeaderID     | leader 的节点 id，方便后续 follower 转发写请求       |
| LeaderCommit | leader 最新提交的日志 index，方便 follower 更新数据进度 |

##### 请求终点
当 Leader 收到心跳请求的时候：
- 如果发送方的 Term 小于自身，直接忽略请求；
- 如果发送方的 Term 大于自身，退位为 Follower 来处理请求。

当 Follower 收到心跳请求的时候：
- 如果发送方的 Term 小于自身，直接忽略；
- 重置 Leader 心跳检测计时器. 查看 LeaderCommit, 看是否有预写日志可以被提交。

若 Candidate 收到心跳请求：
- 如果发送方的 Term 小于自身，直接忽略；
- 如果发送方的 Term 大于自身，将状态转换为 Follower 来处理请求。

#### 5.3 竞选拉票请求
![[Raft-竞选拉票请求.png|center|800]]
竞选拉票请求由 Candidate 发出，来获取多数派的认同，以上位为 Leader。

##### 请求参数
请求参数包含如下部分：
- Term：当前竞选 Candidate 的任期；
- CandidateID：候选人的节点 ID；
- LastLogIndex：候选人最后一笔预写日志的索引；
- LastLogTerm：候选人最后一笔预写日志的任期。

##### 请求终点
当 Leader 收到竞选请求时：
- 如果 Candidate 的任期小于自己的任期，拒绝请求并返回自己的任期；
- 倘若 Candidate 的竞选任期大于自身，退位为 Follower，按照 Follower 的模式处理该请求；

当 Follower 收到竞选请求时：
- 倘若 Candidate 的竞选任期小于自身，拒绝请求，并回复自己的最新任期；
- 倘若自己已经将票投给了其他 Candidate，拒绝请求；
- 倘若 Candidate 的 LastLogTerm 小于自己最后一笔预写日志的 Term，拒绝；
- 倘若 Candidate 的 LastLogTerm 等于自己最后一笔预写日志的 Term，且 Candidate 的 LastLogIndex 小于自己最后一笔预写日志的 index，拒绝；
- 倘若自己已经将票投给了这个 Candidate，接受；（Candidate 侧会幂等去重）
- 倘若 Candidate 的 LastLogTerm 大于自己最后一笔预写日志的 Term，接受；
- 倘若 Candidate 的 LastLogTerm 等于自己最后一笔预写日志的 Term，且 Candidate 的 LastLogIndex 大于等于自己最后一笔预写日志的 Index，接受；

当 Candidate 收到竞选请求时：
- 倘若 Candidate 的竞选任期小于等于自己的竞选任期，拒绝；
- 倘若 Candidate 的竞选任期大于自己的竞选任期，退回 Follower，按照 Follower 的模式处理。

##### 响应参数
响应参数包含如下部分：
- Term：节点当前的任期；
- Granted：是否投了赞成票。

##### Candidate 后处理
1. 倘若多数派投了赞同票（包括自己），晋升为 Leader，竞选任期则为新的国号；
2. 倘若多数派投了反对票，则退回 Follower；
3. 倘若反对票中，出现了比自己更高的任期，退回 Follower，更新任期；
4. 倘若形成多数派决议前，收到了任期大于等于自己的 Leader 的请求，退回 Follower，更新任期；
5. 倘若拉票请求超时，则自增竞选任期，发起新一轮竞选。

##### 小结
通过 Follower 决定投票的判断机制，可以看出，Follower 只愿意将票投给数据状态不滞后于自己的 Candidate. 又由于 Candidate 要获取多数派的赞同票才能上位成为 Leader，换言之，只有数据一致性状态在多数派中处于领先地位的 Candidate 才有资格成为 Leader。

这一项机制非常重要，正是由它保证了 ”两阶段提交，提交即可响应“ 这一流程的合理性。

### 7 Q&A
下面通过对几个经典问题的回答，实现对 Raft 算法原理的补充。

#### 7.1 如何保证一个 Term 中只有一个 Leader？
通过 Raft 的选举机制可以保证。

首先，Candidate 竞选前会自增 Term，因此 Term 在总体上为单调递增趋势；

其次，在选举机制上，一个 Term 内，一个 Follower 只有一票，因此只能投票给一个 Candidate；

最后，基于多数派原则，一个 Candidate 只有拿到半数以上的赞同票才能当选 Leader。

因此，同一个 Term 内，不可能出现有两个 Candidate 同时获得半数以上的赞同票，因此一个 term 至多只有一个 Leader。

#### 7.2 为什么能保证 Term + Index 定位到的日志内容完全相同？
首先，预写日志具有 Append-Only 的性质，只作追加，不存在更新和删除操作；

其次，基于 7.1 可得知，同一个 Term 只有一个 Leader；

因此，在 Term 相同的情况下，所有节点在同一个 Index 上的日志都会与 Term 内 Leader 对应 Index 位置的日志保持一致；

综上，Term 和 Index 共同组成了一个全局唯一标识键. 只要 Term 和 Index 均相同，日志内容一定相同。

#### 7.3 如何保证日志的顺序完全一致？
对于节点 a，一笔 term = x、index = y 的预写日志允许被写入的前提是，其上一笔预写日志的任期和索引一定和 term 为 x 的 leader 的上一笔日志相同；

又由 7.2 小节证明，只要日志的索引和任期相同，其内容一定相同；

进一步采用数学归纳法，可以推导得到，节点 a 从这笔写入日志开始向前追溯的所有日志均与任期为 x 的 leader 完全一致；

倘若节点 b 也存在一笔 term = x、index = y 的日志，那么这笔日志一定也是由 term 为 x 的同一 leader 同步写入；

节点 b 自此向前的所有日志都会与 leader 完全相同；

于是可得，节点 a、b 自此向前的日志都完全相同。

#### 7.4 如何解决选票瓜分问题？
试想一个场景，集群中有 a、b、c 3 个节点，三者网络环境以及硬件配置都非常相近。

其中，c 为 Leader，集齐两个节点形成共识即可视为多数派，接下来发生了如下事件：
1. Leader c 某时刻宕机；
2. 节点 a、b 心跳检测计时器同时超时，因此同时发起竞选；
3. 发起竞选时，a、b 都对任期加1，并且都会先把手中的一票投给自己，然后向对方拉票；
4. 由于 a、b 手中的票都已投给自己，因此会分别拒绝对方的拉票请求；
5. a、b 都无法获得多数派的选票，竞选在同一时刻超时，并且同时发起下一轮竞选；
6. 接下来不断重复（3）-（5）步，a、b 陷入僵持局面，始终无人胜出，导致集群不可用。

解决方案：
每个节点在心跳超时阈值和竞选超时阈值上添加一个随机扰动值，通过这一扰动，避免多个节点在进入完全相同的竞选节奏. 于是进入 Candidate 状态的节点有了先后之分，胜负自然就可见分晓。

#### 7.5 如何保证新任 Leader 存有旧 Leader 的已提交日志？
这是由两阶段提交和选举流程中的多数派原则保证的：
1. 只有被集群多数派完成同步的日志才会被 leader 提交；
2. 在选举流程中，节点只会把票投给日志进度不滞后于自身的 candidate；
3. 在竞选流程，candidate 需要获取多数派的赞同票才能胜任，成为新任 leader.

基于第（3）点可知，新任 leader 的日志进度一定能在竞选流程的多数派中出于不滞后的地位.

而在集群节点个数固定的情况下，本轮竞选流程的多数派和认可前任 leader 同步日志请求的多数派至少存在一个重复的节点，否则就违背了多数派的语义（集群半数以上），因此可以得知，新任 leader 一定拥有前任 leader 那笔被多数派认可的日志，即旧 leader 提交的日志。

#### 7.6 是否一项 Proposal 经过多数派通过就可以提交？
当一笔日志被多数派完成同步后，则后续所有新任的 leader 一定会拥有这笔日志，因此这笔日志已经被集群采纳，可以保证其安全性。

上面的论述看起来天衣无缝，然而，本小节所谈及问题的答案其实是否定的，下面谈及一个极端的 case，并通过一个机制的补充，来让本节所关心的问题被彻底解决。

![[Raft-是否一项 Proposal 经过多数派通过就可以提交？.png|center|800]]

背景：集群中存在 s1 - s5 5 个节点，只需要 3 个节点达成共识，即可形成多数派.
1. Moment1：此时 Leader 为 s1，Term 为 1，s1 接受了一笔写请求，刚将其同步到 s1、s2，还未形成多数派时，s1 就宕机了；
2. Moment2：s5 收获了 s3、s4、s5 的选票，当选 Leader，接受了一笔写请求，只在本机完成预写日志的落盘就宕机了；
3. Moment3：s1 收获了 s1、s2、s3、s4 的选票，重新当选 Leader，继续推进 Term = 1 时那笔遗留写请求的提交，成功将其同步到了 s1、s2、s3，获得多数派的认同，于是提交这笔写请求. 提交之后，s1 又宕机了。
4. Moment4：s5 由于遗留了一笔 Term 为 2 的日志 Term，领先集群所有节点，因此可以收获集群所有节点的选票。于是 s5 再度当选 Leader，继续推进 Term 为 2 时遗留的写请求，由于这笔日志的 Index 与第（3）步中 s1 同步日志的 Index 相同，又因为其 Term 值更大，最终会覆盖 s1、s2、s3 中的老日志，这就导致一笔已经被 s1 提交的日志最终被 s5 回滚了。

注意，在 Raft 算法的设定中，已提交的日志就认为是写入成功了，是绝对不允许被回滚的，这种极端 case 就会 raft 算法的公信力造成破坏。

于是为解决这一问题，raft 算法中新增了一项限制，新上任的 leader 需要至少完成一笔本任期内的写请求，才能够执行提交动作。

补充这一设定后，在上述 case 的第（3）步，Leader s1 尽管完成了 Term 1 遗留日志的同步，也不能执行提交动作. 直到其完成一笔 Term 3 的写请求之后，才能执行老日志的提交. 这是因为此时，集群中的多数派已经被同步了 Term 3 的日志，即使 s1 再发生宕机情况，s5 也不可能凭借 term2 的遗留日志而重新当选了。

事实上，在工程实践上，通常每个 Leader 上任之后，都会向集群广播同步一笔内容为空的日志，称之为 no-op. 只要这个请求被提交了，多数派也就写入了一遍当前任期的日志，于是本小节所谈及的异常问题就不可能再发生了。

#### 7.7 同步日志时如何保证不出现乱序、丢失、重复的问题？
不乱序、不重复：Follower 同步日志前，会校验上一笔日志是否和 Leader 的上一笔完全一致，只有这样才会执行同步动作。

不丢失：基于 ACK 机制保证. 倘若 Leader 超时未收到 Follower 同步日志的 ACK，会重发同步日志请求。

#### 7.8 如何保证各节点已提交的预写日志顺序和内容都完全一致？


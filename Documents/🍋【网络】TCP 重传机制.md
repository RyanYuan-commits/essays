重传机制 TCP 实现可靠传输的方式之一，是通过序列号与确认应答，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。但在错综复杂的网络，传输并不一定那么顺利，TCP 针对数据包丢失的情况，会用 **重传机制** 解决。
### 1 超时重传
重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 `ACK` 确认应答报文，就会重发该数据，也就是我们常说的**超时重传**，它会在数据包丢失和确认应答丢失的时候触发。
#### 1.1 超时时间的设置
我们先来了解一下什么是 `RTT`（Round-Trip Time 往返时延），RTT 指的是**数据发送时刻到接收到确认的时刻的差值**，也就是包的往返时间。
超时重传时间 RTO 的值应该略大于报文往返 RTT 的值，RTO 过大会导致重传较慢，而较小则会导致触发很多无效重传。
但是 RTT 的值是经常变化的，因为网络状况是经常变化的，所以 RTO 应该是一个动态的值。
### 2 快速重传
TCP 还有另外一种快速重传机制，它不以时间为驱动，而是以数据驱动重传。
比如发送方发送了序列号为 1～5 的五条数据，而序列号为 2 的数据丢失了，接收方在收到 3～5 这三条数据的时候，会因为自己只收到了数据 1，而返回 ACK=2；
此时发送方就可以感知到接收方没有收到数据 2，当收到三次同样的 ACK 后，发送方会触发快速重传机制。
这个机制面临着一个问题，就是重传的时候，是 **重传一个**，还是 **重传所有** 的问题，发送方只知道接收方有哪条数据没有接收到，但是从这条数据往后的数据是否接收发送方是无法感知的；为了解决不知道该重传哪些 TCP 报文，于是就有 `SACK` 方法。
### 3 SACK 方法
还有一种实现重传机制的方式叫：`SACK`（ Selective Acknowledgment）， **选择性确认**。
这种方式需要在 TCP 头部「选项」字段里加一个 `SACK` 的东西，配合 `ACK`，发送方可以得知哪些数据已经丢失。
如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 `SACK` 信息发现只有 `200~299` 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。
![[SACK 方法.png|800]]
如果要支持 `SACK`，必须双方都要支持。在 Linux 下，可以通过 `net.ipv4.tcp_sack` 参数打开这个功能（Linux 2.4 后默认打开）。
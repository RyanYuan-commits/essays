### 1 基本介绍
#### 1.1 引入原因
流量控制是对发送方和接受方传递的优化，而拥塞控制是发送方对网络的优化。
一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵，在网络拥堵的时候再发送大量的数据包，可能会导致数据包时延、丢失等情况，此时会触发重传，而重传又会进一步的加重网络负担，这样就进入了恶性的循环；
为了避免这种情况的发生，TCP 被设置成了一个无私的协议，当网络发生拥塞的时候，TCP 会自我牺牲，降低发送的数据量。
#### 1.2 拥塞窗口
拥塞窗口（Congestion Window）是发送方维护的一个的状态变量，它会根据 **网络的拥塞程度动态变化的**，cwnd 的大小反映了当时网络的拥塞程度。
发送方当发现自己接收的 ACK 报文发生了超时重传，就会认为网络出现的拥塞。
### 2 拥塞控制算法
拥塞控制涉及到这四个算法：慢启动、拥塞避免、拥塞发生、快速恢复。
#### 2.1 慢启动
TCP 连接刚刚简历完成后，首先会有一个慢启动的过程，发送方会逐渐增加单词发送数据包的数量；
每当发送方接收到一个接受方的 SDK，拥塞窗口的大小就会 **加一**，整个过程如下图所示：
![[TCP-拥塞控制-慢启动.png|center|800]]
这样的增加方式是 **指数增长** 的，发送上限由慢启动门限（slow start threshold）控制，当发包个数超过慢启动门限，就会触发拥塞避免算法。
#### 2.2 拥塞避免算法
当拥塞窗口 `cwnd` 「超过」慢启动门限 `ssthresh` 就会进入拥塞避免算法，一般来说 `ssthresh` 的大小是 `65535` 字节。
拥塞避免算法的规则是这样的：每当收到一个 ACK，cwnd 增加 $1/cwnd$。
比如，当发送八个数据包，收到八个 ACK，此时发送数量会增加一，此时发送数据包的个数变成了 **线性增长**。
就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。
当触发了重传机制，也就进入了「拥塞发生算法」。
#### 2.3 拥塞发生
针对不同的重传机制（超时重传、快速重传），采用的算法是不同的。
##### 超时重传算法
当发生了「超时重传」，则就会使用拥塞发生算法。
这个时候，ssthresh 和 cwnd 的值会发生变化：
- `ssthresh` 设为 `cwnd/2`，
- `cwnd` 重置为 `1` （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）
接着就重新开始慢启动状态。
![[TCP-拥塞发生-超时重传.png|center|800]]
##### 快速重传算法
还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。
TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 `ssthresh` 和 `cwnd` 变化如下：
- `cwnd = cwnd/2` ，也就是设置为原来的一半;
- `ssthresh = cwnd`;
- 进入「快速恢复算法」
#### 2.4 快速恢复算法
快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，没有必要像 `RTO` 超时那么强烈。
此时拥塞窗口为原来的一半，慢启动门限被设置为和拥塞窗口相等，然后进入快速恢复算法：
- 拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了）；
- 重传丢失的数据包；
- 如果再收到重复的 ACK，那么 `cwnd` 增加 1；
- 如果收到新数据的 ACK 后，把 `cwnd` 设置为第一步中的 `ssthresh` 的值，原因是该 ACK 确认了新的数据，说明从丢失 ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；
![[TCP-拥塞控制-快速恢复.png|center|800]]
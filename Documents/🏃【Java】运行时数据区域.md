## 1 线程私有区域
### 1.1 程序计数器

程序计数器是一块较小的内存空间，可以看作当前线程执行的字节码的行号指示器。在 java 虚拟机的概念模型中，字节码解释器工作就是通过改变程序计数器的值来指定下一个要执行的代码，由此来实现分支、循环、跳转、异常处理、线程恢复等等基础功能。

程序计数器的作用是保存现场，因为 Java 是多线程的，线程之间可以互相的切换（CPU 的时间片的切换），在切换之前需要保存当前线程执行到了哪一行，以便于下次线程得到 CPU 的时间片的时候可以知道应该从什么位置开始执行。

如果线程执行的是一个 Java 方法，那此时程序计数器指向的就是正在执行的虚拟机字节码地址，如果执行的是本地 Native 方法，那么这个计数器的值为 Null。

![[程序计数器.png|600]]

这个内存区域是 《Java 虚拟机规范》 中唯一一个没有规定任何 OutOfMemoryError（OOM） 的区域，所以程序计数器使用的内存，我们程序员不需要去关心，也不需要考虑回收的情况。
### 1.2 虚拟机堆栈

虚拟机堆栈是以线程为单位的一块内存，它的生命周期与线程的生命周期相同；每个方法被执行的时候，JVM 会同步创建一个栈帧（Stack Frame），用于存储局部变量表、操作数栈、动态连接、方法出口信息。

![[栈帧中存储的信息.png|700]]

Java 中所有的传参都是值传递，基本类型传递的是值本身，引用类型传递的是引用地址的值，这些值就是存储在局部变量表的。
### 1.3 本地方法栈

本地方法栈专门用于支持本地方法（也称为本机方法），即使用非 Java 语言（如 C 或 C++）编写的代码，这些方法通过 Java Native Interface (JNI) 调用。JNI 允许 Java 代码与本地代码进行交互，以实现一些平台相关的功能或优化性能。
本地方法栈的特点：
1. 存储本地方法调用信息：本地方法栈保存每个线程调用的本地方法的相关信息，包括本地变量、输入参数、返回值等。
2. 线程私有：本地方法栈和 Java 栈一样，每个线程都有一个独立的本地方法栈。
   一个线程调用本地方法时，其调用信息会被压入其本地方法栈中。
3. 动态调整：栈的大小可以在 JVM 启动时指定，通常 JVM 实现会动态调整本地方法栈的大小以适应不同的需求。
## 2 线程共享区域
### 2.1 堆区【存放对象实例】

堆区在 JVM 启动的时候创建，是虚拟机所管理的最大的一块内存，被所有线程所共享；
堆内存区域存在的唯一目的就是存放对象实例，在 《Java 虚拟机规范》中提到，Java 中所有的对象实例都在这里分配内存。
Java 堆区域是垃圾处理器管理的区域，因此它也被称为 GC 堆。
![[堆空间.png|600]]
- 年轻代（Young Generation）：年轻代是Java堆内存中存储新创建对象的区域。年轻代通常进一步划分为三个子区域：
	- Eden区：所有新对象首先分配在Eden区。当Eden区满时，会触发一次年轻代垃圾收集（Young GC或Minor GC），这些对象要么被移动到Survivor区，要么被清除。
	- 两个Survivor区（S0和S1）：Survivor 区用于保存 从 Eden 区复制过来并且在垃圾收集中存活的对象。
		- 每次垃圾收集后，Eden 区存活的对象会被复制到其中一个 Survivor 区（通常是空的）。
		- 在后续的垃圾收集中，如果对象再次存活，它们会被复制到另一个 Survivor 区。
		- 这个过程反复进行，直到对象足够老，被晋升到老年代。
- 老年代（Old Generation）：老年代是存储长生命周期对象的区域。对象在年轻代经过多次垃圾收集后，如果仍然存活，会被晋升到老年代。
	- 老年代的垃圾收集称为老年代垃圾收集（Old GC或Major GC），这个过程通常比年轻代垃圾收集更耗时，因为老年代中的对象存活时间更长且数量更多。
	- 年轻代是比老年代的空间小的，因为经过大量的数据分析发现，大部分的对象都是朝生夕死的，也就是存活时间并不是很长，所以大部分的类其实是保存在年轻代中的，而将年轻代的区域设置的小一点更有助于 GC 回收。
### 2.2 方法区【存放静态信息】

方法区中存储的都是在整个进程中永远唯一的元素，比如类信息、静态变量、运行时常量池等等；在 JVM 加载一个类时，它首先会读取 Class 文件中的常量池信息，并将其复制到运行时常量池中。
当程序运行时，如果需要使用某个常量，它可以从运行时常量池中获取。
运行时常量池允许动态添加新的常量，这是通过反射、字符串连接或其他方式实现的。
#### 方法区中存储的数据

- 类信息（Class Metadata）：类和接口的结构信息：包括类名、父类名、接口名、修饰符、常量池等。
- 字段信息：包括字段名、类型、修饰符等。
- 方法信息：包括方法名、返回类型、参数类型、修饰符等。
- 运行时常量池（Runtime Constant Pool）：存储编译期生成的各种字面量（如字符串常量）以及符号引用（如类和方法的引用）。这些常量在类加载时被解析，并在运行时使用。
- 方法的字节码（Bytecodes of Methods）：存储每个方法的字节码指令，供 JVM 执行。
- 静态变量（Static Variables）：存储类的静态字段，这些字段在类加载时被分配内存。
- JIT 编译后的代码（JIT Compiled Code）：如果使用了即时编译器（Just-In-Time Compiler，简称 JIT），那么 JIT 编译后的本地机器码也会存储在方法区中。
#### 方法区实现方式的演变

方法区 和 永久代 以及 元空间 的关系很像 Java 中接口和类的关系，类实现了接口，这里的类就可以看作是永久代和元空间，接口可以看作是方法区，永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。
并且，永久代是 JDK 1.8 之前的方法区实现，JDK 1.8 及以后方法区的实现变成了元空间。
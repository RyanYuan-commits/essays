# 快慢指针技巧
## 原地修改
数组问题中比较常见的快慢指针技巧，是让你原地修改数组。
比如力扣的第 26 题，「[删除有序数组中的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)」：给你一个 **非严格递增排列** 的数组 `nums` ，请你 **原地** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。
```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```
高效解决这道题就要用到快慢指针技巧：
我们让慢指针 `slow` 走在后面，快指针 `fast` 走在前面探路，找到一个不重复的元素就赋值给 `slow` 并让 `slow` 前进一步。
这样，就保证了 `nums[0..slow]` 都是无重复的元素，当 `fast` 指针遍历完整个数组 `nums` 后，`nums[0..slow]` 就是整个数组去重之后的结果。
```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int slow = 0;
        int fast = 1;
        int pre = nums[0];
        while (fast < nums.length) {
            if (nums[fast] != pre) {
                nums[++slow] = nums[fast];
            }
            pre = nums[fast];
            fast++;
        }
        return slow + 1;
    }
}
```
再简单扩展一下，看看力扣第 83 题「[删除排序链表中的重复元素](https://leetcode.cn/problems/remove-duplicates-from-sorted-list)」，如果给你一个有序的单链表，如何去重呢？
其实和数组去重是一模一样的，唯一的区别是把数组赋值操作变成操作指针而已。
```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null) return head;
        ListNode fast = head.next;
        ListNode slow = head;
        int preVal = head.val;
        while (fast != null) {
            if (fast.val != preVal) {
                slow.next = fast;
                slow = slow.next;
            }
            preVal = fast.val;
            fast = fast.next;
        }
        slow.next = null;
        return head;
    }
}
```
还有一些需要原地修改数组的题目，比如力扣的第 27 题「[移除元素](https://leetcode.cn/problems/remove-element/submissions/575355356/)」，给你一个数组 `nums` 和一个值 `val`，你需要 原地 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。
```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```
本题需要保证元素的相对顺序，第一种思路是使用冒泡排序的思路，将非零元素不断向前冒泡，直到遍历完成数组：
```java
class Solution {
    public void moveZeroes(int[] nums) {
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] != 0) {
                int cur = i;
                while (cur >= 1 && nums[cur - 1] == 0) {
                    int temp = nums[cur];
                    nums[cur] = nums[cur - 1];
                    nums[cur - 1] = temp;
                    cur = cur - 1;
                }
            }
        }
    }
}
```
第二种思路，依靠上面的移除元素，将数组中的所有 0 移除掉，然后再补上 0 即可：
```java
class Solution {
    public void moveZeroes(int[] nums) {
        int cur = 0;
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] != 0) {
                nums[cur++] = nums[i];
            }
        }
        for (int i = cur; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
}
```
## 滑动窗口
数组中另一大类快慢指针的题目就是「滑动窗口算法」。另一篇文章 [滑动窗口算法核心框架详解](https://labuladong.online/algo/essential-technique/sliding-window-framework/) 给出了滑动窗口的代码框架：
```java
// 滑动窗口算法框架伪码
int left = 0, right = 0;

while (right < nums.size()) {
    // 增大窗口
    window.addLast(nums[right]);
    right++;
    
    while (window needs shrink) {
        // 缩小窗口
        window.removeFirst(nums[left]);
        left++;
    }
}
```
具体的题目本文就不重复了，这里只强调滑动窗口算法的快慢指针特性：`left` 指针在后，`right` 指针在前，两个指针中间的部分就是「窗口」，算法通过扩大和缩小「窗口」来解决某些问题。
# 左右指针常用算法
## 二分查找
具体看力扣第 704 题「[二分查找](https://leetcode.cn/problems/binary-search/)」，给定一个 `n` 个元素有序的（升序）整型数组 `nums` 和一个目标值 `target`  ，写一个函数搜索 `nums` 中的 `target`，如果目标值存在返回下标，否则返回 `-1`。
二分查找必须要求数组是顺序排列的，此外，需要注意范围的有效性，详细可以看 [[🍧【数组】二分查找算法总结]]
```java
class Solution {
    public int search(int[] nums, int target) {
        // 搜索范围左闭右开
        int left = 0;
        int right = nums.length;
        while (left < right) {
            int mid = (left + right) / 2;
            if (nums[mid] > target) {
                right = mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                return mid;
            }
        }
        return -1;
    }
}
```
## N 数之和问题
力扣第 167 题「[两数之和 II](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted)」
给你一个下标从 **1** 开始的整数数组 `numbers` ，该数组已按 **非递减顺序排列**  ，请你从数组中找出满足相加之和等于目标数 `target` 的两个数。如果设这两个数分别是 `numbers[index1]` 和 `numbers[index2]` ，则 `1 <= index1 < index2 <= numbers.length` 。
```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。返回 [1, 2] 。
```
两个指针 left 和 right，分别指向数组的开头和结尾，计算 `nums[left] + nums[right]` 的值，并与 `target` 做比较，根据结果移动左右指针
```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;
        while (left < right) {
            int num = numbers[left] + numbers[right];
            if (num < target) {
                left++;
            } else if (num > target) {
                right--;
            } else {
                return new int[]{left + 1, right + 1};
            }
        }
        return null;
    }
}
```
## 反转数组
力扣第 344 题「[反转字符串](https://leetcode.cn/problems/reverse-string)」
编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。
不要给另外的数组分配额外的空间，你必须原地修改输入数组、使用 O(1) 的额外空间解决这一问题。
```
输入：s = ["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```
```java
class Solution {
    public void reverseString(char[] s) {
        int left = 0;
        int right = s.length - 1;
        while (left < right) {
            char c = s[left];
            s[left] = s[right];
            s[right] = c;
            left++;
            right--;
        }
    }
}
```
## 回文串判断
力扣第 5 题「[最长回文子串](https://leetcode.cn/problems/longest-palindromic-substring)」，给你一个字符串，让你用双指针技巧从中找出最长的回文串。
第一种思路是运用动态规划，需要注意一下 dp 过程中的相互依赖，比如 (i, j) 是根据 (i + 1, j - 1) 推出的，所以要保证遍历到这个位置的时候，这些位置已经被初始化，所以 i 需要倒序遍历而 j 需要正序遍历。
```java
class Solution {
    public String longestPalindrome(String s) {
        char[] arr = s.toCharArray();
        int len = arr.length;
        int startIndex = 0;
        int endIndex = 0;

        boolean[][] dp = new boolean[len][len];
        for (int i = 0; i < len; i++) {
            // 对角线上的元素初始化为 true
            dp[i][i] = true;
        }

        for (int i = len - 1; i >= 0; i--) {
            for (int j = i + 1; j < len; j++) {
                if (arr[i] == arr[j]) {
                    if (j - i == 1) dp[i][j] = true;
                    else if (dp[i + 1][j - 1]) dp[i][j] = true;  
                }
                if (dp[i][j]) {
                    if ((j - i + 1) > (endIndex - startIndex + 1)) {
                        startIndex = i;
                        endIndex = j;
                    }
                }
            }
        }

        int offset = endIndex - startIndex + 1;
        return new String(arr, startIndex, offset);
    }
}
```
还可以采用中心扩散的思路，也就是从一个节点开始向两边拓展，然后不断比较：
```java
    // 在 s 中寻找以 s[l] 和 s[r] 为中心的最长回文串
    String palindrome(String s, int l, int r) {
        // 防止索引越界
        while (l >= 0 && r < s.length() && s.charAt(l) == s.charAt(r)) {
            // 双指针，向两边展开
            l--; 
            r++;
        }
        // 返回以 s[l] 和 s[r] 为中心的最长回文串
        return s.substring(l + 1, r);
    }
```
```java
    public String longestPalindrome(String s) {
        String res = "";
        for (int i = 0; i < s.length(); i++) {
            // 以 s[i] 为中心的最长回文子串
            String s1 = palindrome(s, i, i);
            // 以 s[i] 和 s[i+1] 为中心的最长回文子串
            String s2 = palindrome(s, i, i + 1);
            // res = longest(res, s1, s2)
            res = res.length() > s1.length() ? res : s1;
            res = res.length() > s2.length() ? res : s2;
        }
        return res;
    }
```


### 1 三次握手
![[TCP 三次握手的过程.png|600]]
一开始，客户端和服务端都处于 `CLOSE` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态
- 客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1`，表示 `SYN` 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态。
- 服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为 `1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态。
- 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 `ESTABLISHED` 状态。
- 服务端收到客户端的应答报文后，也进入 `ESTABLISHED` 状态。
### 2 为什么需要三次？
#### 2.1 避免历史连接
如果使用两次握手的话，大致过程是这样的客户端发送 SYN 报文，服务端返回 ACK 报文，连接成功。
在这个过程中，服务端在收到请求后就会认为连接已经建立，而不会再次跟客户端确认；
如果客户端发送的请求被阻塞，这个请求在网络中流转一段时间后到达服务端，服务端仍然会认为这是一个健康的连接，这就是历史连接问题。
#### 2.2 同步双方的序列号
TCP 协议的通信双方， 都必须维护一个「序列号」， 序列号是可靠传输的一个关键因素，它的作用：
- 接收方可以去除重复的数据；
- 接收方可以根据数据包的序列号按序接收；
- 可以标识发送出去的数据包中， 哪些是已经被对方收到的（通过 ACK 报文中的序列号知道）；
而两次握手只保证了一方的初始序列号能被对方成功接收，没办法保证双方的初始序列号都能被确认接收。
#### 2.3 避免资源浪费
如果只有「两次握手」，当客户端发生的 `SYN` 报文在网络中阻塞，客户端没有接收到 `ACK` 报文，就会重新发送 `SYN`；
由于没有第三次握手，服务端不清楚客户端是否收到了自己回复的 `ACK` 报文，所以服务端 **每收到一个 `SYN` 就只能先主动建立一个连接**。
如果客户端发送的 `SYN` 报文在网络中阻塞了，重复发送多次 `SYN` 报文，那么服务端在收到请求后就会建立多个冗余的无效链接，造成不必要的资源浪费。
### 3 请求丢失问题
#### 3.1 第一次握手丢失
当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 `SYN_SENT` 状态。
在这之后，如果客户端迟迟收不到服务端的 SYN-ACK 报文（第二次握手），就会触发「超时重传」机制，重传 SYN 报文，而且**重传的 SYN 报文的序列号都是一样的**。
不同版本的操作系统可能超时时间不同，有的 1 秒的，也有 3 秒的，这个超时时间是写死在内核里的；
在 Linux 中，重传的次数由 tcp_syn_retries 参数控制，参数的默认值是 5。
通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，每次超时的时间是上一次的 2 倍。
#### 3.2 第二次握手丢失
当服务端收到客户端的第一次握手后，就会回 SYN-ACK 报文给客户端，这个就是第二次握手，此时服务端会进入 `SYN_RCVD` 状态。
因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是客户端就会触发超时重传机制，重传 SYN 报文。
同时，服务端因为长时间没有收到客户端的 ACK 报文，也会触发自己的重传机制，重发 SYN-ACK 报文，所以第二次握手丢失后，客户端和服务端都会重传报文。
在 Linux 下，SYN-ACK 报文的最大重传次数由 `tcp_synack_retries`内核参数决定，默认值是 5。
#### 3.3 第三次握手丢失
客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 `ESTABLISH` 状态。
因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制。
### 4 SYN 攻击
#### 4.1 全连接与半连接队列
在 TCP 三次握手的时候，Linux 内核会维护两个队列，分别是：
- 半连接队列，也称 SYN 队列；
- 全连接队列，也称 accept 队列；
正常建立连接的流程是这样的：
- 当服务端接收到客户端的 SYN 报文时，会创建一个半连接的对象，然后将其加入到内核的「 SYN 队列」；
- 接着发送 SYN + ACK 给客户端，等待客户端回应 ACK 报文；
- 服务端接收到 ACK 报文后，从「 SYN 队列」取出一个半连接对象，然后创建一个新的连接对象放入到「 Accept 队列」；
- 应用通过调用 `accpet()` socket 接口，从「 Accept 队列」取出连接对象。
当 SYN 队列满了之后就无法再接收新的连接了，SYN 攻击正是通过发送大量 SYN 请求来填满 SYN 队列。
#### 4.2 解决方案
##### 调大数据包队列
当网卡接收数据包的速度大于内核处理的速度时，会有一个队列保存这些数据包。
控制该队列的最大值如下参数，默认值是 1000，我们要适当调大该参数的值，比如设置为 10000：
```sh
net.core.netdev_max_backlog = 10000
```
##### 增大 TCP 半连接队列
增大 TCP 半连接队列，要同时增大下面这三个参数：
- 增大 `net.ipv4.tcp_max_syn_backlog`
- 增大 `listen()` 函数中的 `backlog`
- 增大 `net.core.somaxconn`
##### 跳过半连接
开启 `syncookies` 功能就可以在不使用 SYN 半连接队列的情况下成功建立连接，相当于绕过了 SYN 半连接来建立连接。具体过程：
- 当「SYN 队列」满之后，后续服务端收到 SYN 包，不会丢弃，而是根据算法，计算出一个 `cookie` 值；
- 将 `cookie` 值放到第二次握手报文的「序列号」里，然后服务端回第二次握手给客户端；
- 服务端接收到客户端的应答报文时，服务端会检查这个 ACK 包的合法性。如果合法，将该连接对象放入到「Accept 队列」；
- 最后应用程序通过调用 `accpet()` 接口，从「Accept 队列」取出连接。
##### 方式四：减少重传次数
当服务端受到 SYN 攻击时，就会有大量处于 SYN_REVC 状态的 TCP 连接，处于这个状态的 TCP 会重传 SYN-ACK ，当重传超过次数达到上限后，就会断开连接。
那么针对 SYN 攻击的场景，我们可以减少 `SYN-ACK` 的重传次数，以加快处于 `SYN_REVC` 状态的 TCP 连接断开。
`SYN-ACK` 报文的最大重传次数由 `tcp_synack_retries`内核参数决定（默认值是 5 次），比如将 tcp_synack_retries 减少到 2 次：
```sh
$ echo 2 > /proc/sys/net/ipv4/tcp_synack_retries
```

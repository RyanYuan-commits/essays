我们在开发一些远程过程调用（RPC）的程序时，通常会涉及对象的序列化/反序列化的问题，例如一个 “Person” 对象从客户端通过TCP方式发送到服务器端。

由于 TCP 协议（或者 UDP 等类似低层协议）只能发送字节流，所以需要应用层将 Java POJO 对象“序列化”成字节流，发送过去之后，数据接收端再将字节流“反序列化”化成 Java POJO 对象即可。

“序列化” 和 “反序列化” 一定会涉及 POJO 的编码和格式化（Encoding & Format），
目前我们可选择的编码方式有：

- 使用 JSON。将 Java POJO 对象转换成 JSON 结构化字符串。基于 HTTP 协议，在 Web 应用、移动开发方面等，这是常用的编码方式，因为 JSON 的可读性较强。但是它的性能稍差。
- 基于 XML。和 JSON 一样，数据在序列化成字节流之前都转换成字符串。可读性强，性能差，异构系统、Open API 类型的应用中常用。
- 使用 Java 内置的编码和序列化机制，可移植性强，性能稍差，无法跨平台（语言）。
- 开源的二进制的序列化/反序列化框架，例如 Apache Avro，Apache Thrift、Protobuf 等。
	- 前面的两个框架和Protobuf相比，性能非常接近，而且设计原理如出一辙；
	- 其中 Avro 在大数据存储（RPC 数据交换、本地存储）时比较常用；
	- Thrift的亮点在于内置了 RPC 机制，所以在开发一些 RPC 交互式应用时，客户端和服务器端的开发与部署都非常简单。

如何选择序列化/反序列化框架呢？评价一个序列化框架的优缺点，大概从两个方面着手：

- 结果数据大小，原则上说，序列化后的数据尺寸越小，传输效率越高。
- 结构复杂度，这会影响序列化/反序列化的效率，结构越复杂，越耗时。

理论上来说，对于对性能要求不是太高的服务器程序，可以选择 JSON 文本格式的序列化框架；

对于性能要求比较高的服务器程序，则应该选择传输效率更高的二进制序列化框架，建议是 Protobuf。

Protobuf 是一个高性能、易扩展的序列化框架，性能比较高，其性能的有关的数据可以参看官方文档。Protobuf 本身非常简单，易于开发，而且结合 Netty 框架，可以非常便捷地实现一个通信应用程序。

反过来，Netty 也提供了相应的编解码器，为 Protobuf 解决了有关 Socket 通信中“半包、粘包”等问题。
![[MySQL-锁的分类-思维导图.png]]
### 1 全局锁
#### 1.1 全局锁的使用
要使用全局锁，则要执行这条命令：
```
flush tables with read lock
```
执行后，**整个数据库就处于只读状态了**，任何对于表数据、表结构、库的修改都会被阻塞。

如果要释放全局锁，则要执行这条命令：
```
unlock tables
```
当然，当会话断开了，全局锁会被自动释放。
#### 2.1 全局锁的应用场景和缺点
全局锁主要应用于做**全库逻辑备份**，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。
加上全局锁，意味着整个数据库都是只读状态。
那么如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。
#### 2.3 如何避免全局锁的问题？
有的，如果数据库的引擎支持的事务支持**可重复读的隔离级别**，那么在备份数据库之前先开启事务，会先创建 Read View，然后整个事务执行期间都在用这个 Read View，而且由于 MVCC 的支持，备份期间业务依然可以对数据进行更新操作。
因为在可重复读的隔离级别下，即使其他事务更新了表的数据，也不会影响备份数据库时的 Read View，这就是事务四大特性中的隔离性，这样备份期间备份的数据一直是在开启事务时的数据。
当然，这个方案可以解决数据库备份的时候无法执行事务的问题，但是，它无法保证备份的数据和备份结束之后库中的数据是相同的，因为基于 MVCC 的修改并不会同步到备份的数据中，不过这点时效性就不是备份操作需要考虑的问题了。
备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 `–single-transaction` 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持可重复读隔离级别的事务的存储引擎。
### 2 表级锁 
#### 2.1 表锁
如果我们想对学生表（t_student）加表锁，可以使用下面的命令：
```sql
-- 表级别的共享锁，也就是读锁；
lock tables t_student read;

-- 表级别的独占锁，也就是写锁；
lock tables t_stuent write;
```
需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。如果本线程对学生表加了「共享读锁」，那么本线程接下来如果要对学生表执行写操作的语句，和其他线程一样，都是会被阻塞的。
可以使用下面这条命令，会释放当前会话的所有表锁：
```sql
unlock tables;
```
当会话退出后，也会释放所有表锁。
#### 2.2 元数据锁
##### 介绍
所谓的元数据（MDL），就是表结构。
我们不需要显示的使用 MDL 锁，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：
- 当对一个表执行 CRUD 的时候，表结构是不允许变更的，此时会加上「MDL 读锁」。
- 同样，当一个表的表结构被修改的时候，是不允许对表内的数据进行读取和修改操作的，此时会加上「MDL 写锁」。
##### 释放时机
MDL 是在事务提交后才会释放，这意味着**事务执行期间，MDL 是一直持有的**。
那如果数据库有一个长事务（所谓的长事务，就是开启了事务，但是一直还没提交），那在对表结构做变更操作的时候，可能会发生意想不到的事情，比如下面这个顺序的场景：
1. 线程 A 先开启事务，然后执行 select 语句，此时就先对该表加上 MDL 读锁；
2. 线程 B 也执行了同样的 select 语句，此时并不会阻塞，因为「读读」并不冲突；
3. 线程 C 修改了表字段，此时由于线程 A 的事务并没有提交，也就是 MDL 读锁还在占用着，线程 C 无法申请到 MDL 写锁，被阻塞，
那么在线程 C 阻塞后，后续有对该表的 select 语句，就都会被阻塞，如果此时有大量该表的 select 语句的请求到来，就会有大量的线程被阻塞住，这时数据库的线程很快就会爆满了。
这是因为申请 MDL 锁的操作会形成一个队列，队列中 **写锁获取优先级高于读锁**，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。
所以为了能安全的对表结构进行变更，在对表结构变更前，先要看看数据库中的长事务，是否有事务已经对表加上了 MDL 读锁，如果可以考虑 kill 掉这个长事务，然后再做表结构的变更。
#### 2.3 意向锁
**意向锁的目的是为了快速判断表里是否有记录被加锁**，日常加的锁大部分是行级别的，加锁的位置是索引，如果没有「意向锁」，那么加「独占表锁」时，就需要遍历表里所有记录，查看是否有记录存在独占锁，这样效率会很慢。
- 在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」
- 在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」
意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（lock tables ... read）和独占表锁（lock tables ... write）发生冲突。
#### 2.4 自增锁
当我们给某一列加上 `AUTO-INCREMENT` 修饰的时候，之后插入数据的时候，就不需要再指定这一列的值，而是会自动指定一个递增的值，这一操作的安全性主要是通过 AUTO-INC 锁实现的。
**在插入数据时，会加一个表级别的 AUTO-INC 锁**，然后为被 `AUTO_INCREMENT` 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。
##### 轻量级自增锁
一个事务在持有 AUTO-INC 锁的过程中，其他事务的如果要向该表插入语句都会被阻塞，从而保证插入数据时，被 `AUTO_INCREMENT` 修饰的字段的值是连续递增的。
但是，AUTO-INC 锁在大量数据插入的场景下，会影响插入性能，因为另一个事务中的插入会被阻塞，因此，在 MySQL 5.1.22 版本开始，InnoDB 存储引擎提供了一种**轻量级的锁**来实现自增。一样也是在插入数据的时候，会为被 `AUTO_INCREMENT` 修饰的字段加上轻量级锁，然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁。
##### 自增锁控制选项
InnoDB 存储引擎提供了个 `innodb_autoinc_lock_mode` 的系统变量，是用来控制选择用 AUTO-INC 锁，还是轻量级的锁。
- 当 `innodb_autoinc_lock_mode = 0`，就采用 AUTO-INC 锁，语句执行结束后才释放锁；
- 当 `innodb_autoinc_lock_mode = 2`，就采用轻量级锁，申请自增主键后就释放锁，并不需要等语句执行后才释放。
- 当 `innodb_autoinc_lock_mode = 1`：
    - 普通 insert 语句，自增锁在申请之后就马上释放；
    - 类似 insert … select 这样的批量插入数据的语句，自增锁还是要等语句结束后才被释放；
##### 轻量级自增锁带来的集群同步问题
![[轻量级自增锁带来的集群同步问题案例.png|600]]
session A 往表 t 中插入了 4 行数据，然后创建了一个相同结构的表 t2，然后两个 session 同时执行向表 t2 中插入数据。
如果 innodb_autoinc_lock_mode = 2，意味着「申请自增主键后就释放锁，不必等插入语句执行完」。那么就可能出现这样的情况：
- session B 先插入了两个记录，(1,1,1)、(2,2,2)；
- 然后，session A 来申请自增 id 得到 id=3，插入了（3,5,5)；
- 之后，session B 继续执行，插入两条记录 (4,3,3)、 (5,4,4)。
可以看到，session B 的 insert 语句，生成的 id 不连续。
当「主库」发生了这种情况，bin log 面对 t2 表的更新只会记录这两个 session 的 insert 语句，如果 `binlog_format=statement`，记录的语句就是原始语句。记录的顺序要么先记 session A 的 insert 语句，要么先记 session B 的 insert 语句。

但不论是哪一种，这个 binlog 拿去「从库」执行，这时从库是按「顺序」执行语句的，只有当执行完一条 SQL 语句后，才会执行下一条 SQL。因此，在从库上「不会」发生像主库那样两个 session 「同时」执行向表 t2 中插入数据的场景。所以，在备库上执行了 session B 的 insert 语句，生成的结果里面，id 都是连续的。这时，主从库就发生了数据不一致。
要解决这问题，binlog 日志格式要设置为 row，这样在 binlog 里面记录的是主库分配的自增值，到备库执行的时候，主库的自增值是什么，从库的自增值就是什么。当 `innodb_autoinc_lock_mode=2` 时，并且 `binlog_format=row`，既能提升并发性，又不会出现数据一致性问题。
### 3 行级锁
在数据库中，有这样两种锁：S 锁（共享锁）和 X 锁（排他锁）是用于控制并发访问。
#### 3.1 记录锁
记录锁（Record Lock）锁住的是一条记录，有 S 锁和 X 锁之分的。
例如，当一个事务执行了这样的语句：
```sql
begin;
select * from t_test where id = 1 for update;
```
就是对 `t_test` 表中主键 id 为 1 的这条记录加上 X 型的记录锁，这样其他事务就无法对这条记录进行修改了。当事务执行 `commit` 后，事务过程中生成的锁都会被释放。
#### 3.2 间隙锁
间隙锁（Gap Lock）只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。
假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。
间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，**间隙锁之间是兼容的**，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的。
#### 3.3 临键锁
临键锁（Next-Key Lock）是记录锁和间隙锁的组合，锁定一个范围，并且锁定记录本身。
假设，表中有一个范围 id 为 `(3，5]` 的临键锁，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。
所以，临键锁即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中，临键锁包含间隙锁和记录锁，所以在对临键锁的范围内添加间隙锁或者记录锁都会被阻塞。
#### 3.4 插入意向锁
一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁，如果有的话，插入操作就会发生**阻塞**，并且生成一个插入意向锁，表明有事务希望插入记录，直到拥有间隙锁的那个事务提交为止。
举个例子，假设事务 A 已经对表加了一个范围 id 为 `(3，5)` 间隙锁。当事务 A 还没提交的时候，事务 B 向该表插入一条 `id = 4` 的记录，但这个范围被事务 A 加上了间隙锁，此时事务 B 会生成一个插入意向锁，然后将锁的状态设置为等待状态，随后事务 B 阻塞，直到事务 A 提事务。
插入意向锁名字虽然有意向锁，但是它并不是意向锁，它是一种 **特殊的间隙锁**，属于行级别锁。
如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。
插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁。
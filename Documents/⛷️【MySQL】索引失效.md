### 1 对索引使用左或者左右模糊匹配
```sql
-- name 字段为二级索引
select * from t_user where name like '%林';
```
![[对索引使用左或者左右模糊匹配.png]]
索引 B+ 树是按照「索引值」有序排列存储的，只能根据前缀进行比较。
### 2 对索引使用函数
```sql
-- name 为二级索引
select * from t_user where length(name)=6;
```
索引保存的是索引字段的原始值，而不是经过函数计算后的值，自然就没办法走索引了。
### 3 对索引进行表达式计算
```sql
explain select * from t_user where id + 1 = 10;
```
但是，如果把查询语句的条件改成 where id = 10 - 1，这样就不是在索引字段进行表达式计算了，于是就可以走索引查询了。
索引保存的是索引字段的原始值，而不是 id + 1 表达式计算后的值，所以无法走索引，只能通过把索引字段的取值都取出来，然后依次进行表达式的计算来进行条件判断，因此采用的就是全表扫描的方式。
### 4 对索引隐式的类型转化
执行下列的查询语句，其中 `phone` 的类型是 `VARCHAR`，`id` 是 INT 类型：
```sql
explain select * from t_user where phone = 1300000001;
explain select * from t_user where id = '1';
```
 第一个语句会执行全表查询，而第二个会走索引查询，这是因为MySQL 在遇到字符串和数字比较的时候，会把 **字符串转为数字** 再比较，此时第一个查询语句就等价于：
```sql
select * from t_user where CAST(phone AS signed int) = 1300000001;
```
### 5 联合索引非最左匹配
原因是，在联合索引的情况下，数据是按照索引第一列排序，第一列数据相同时才会按照第二列排序。
也就是说，如果我们想使用联合索引中尽可能多的列，查询条件中的各个列必须是联合索引中从最左边开始连续的列。如果我们仅仅按照第二列搜索，肯定无法走索引。
### 6 WHERE 子句中的 OR
在 WHERE 子句中，如果在 OR 前的条件列是索引列，而在 OR 后的条件列不是索引列，那么索引会失效。
举个例子，比如下面的查询语句，id 是主键，age 是普通列，从执行计划的结果看，是走了全表扫描。
```sql
select * from t_user where id = 1 or age = 18;
```
这是因为 OR 的含义就是两个只要满足一个即可，因此只有一个条件列是索引列是没有意义的，只要有条件列不是索引列，就会进行全表扫描。
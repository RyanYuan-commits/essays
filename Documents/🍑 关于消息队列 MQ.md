MQ，是 Message Queue 消息队列的简称，它的是应用程序之间（生产者和消费者）的一个通信方式。
### 1 基础理解
#### 1.1 同步调用和异步调用
👉 **同步调用** 的时候调用者会 **阻塞** 等待被调用函数或方法执行完成，并且在完成后才继续执行后续代码。
> 💡 那这样会出现什么问题呢？
> 回想一下平时充话费的场景，当我们点击支付了之后，当余额被扣减完之后就可以直接退出了，其实是没有等待服务状态更新，和后面进行的很多业务的，
> 比如短信通知服务也是在充值以后一段时间才会通知的，这其实就是一种异步的方式。

👉试想一下如果是同步调用会出现什么场景？
>答案是界面会卡住，等到一切短信发送完成才能得到 **结果**，这就导致了**等待时间的延长**；将视角再放的深一点，如果将这些业务都做成同步的话，其中一个业务的失败会导致所有业务的 **级联失败**，也就是如果短信通知业务失效了，钱甚至会被退回来，这就导致了用户体验的问题；再将视角放到程序员身上，如果设计一个同步业务，有新的业务加入进来，要去该原来的代码，这就导致了 **耦合性很高** 的问题。

不难总结出来同步调用的问题
- 加需求的问题（耦合性很差）
- 性能的问题，客户等待时间过长
- 一个调用的失败导致级联失败
但任何事物都有两面性，同步调用的优势就是： **立即得到响应的结果** 时效性非常好，很多业务必须要一次执行完毕且需要结果才能进行，比如银行转账，需要保证双方都成功才能进行。
👉 而异步调用正好是相反，对于一些不是那么急于知道结果的业务，可以在返回给用户结果后再执行，这就引出了它的优势：首先是 **解耦合**，业务不需要写在一个代码上，而是可以以微服务的形式拆分开；其次，**立即返回 **给 用户结果，用户无需等待；还可以实现 **故障的隔离**，一个服务的问题不会导致整个业务的级联失败；最后是可以缓存消息，当消息很多的时候可以 **错峰执行**，达到削峰填谷的作用。
但缺点就是不能立刻得到处理的结果，时效性比较差，同时实现依赖于 Broker（代理），如果 Broker 出现问题会导致严重的后果。
👉 异步调用中会出现三个角色，分别是消息发送者、消息代理、和消息接收者；消息发送者发送消息到消息代理然后就可以继续执行，消息代理负责将消息转发给消息接收者，剩余的部分在消息接收者那里执行。
#### 1.2 什么是 MQ？
👉 `MQ`（Message Queue），消息队列，字面来看就是存放消息的队列；也就是异步调用中的 `Broker`；这个命名也就解释了它的实现机制：`MQ `提供了一种 **异步通信** 的方式，允许将消息发送到**队列**中，并由接收者从**队列**中获取和处理这些消息。`MQ ` 通常被用于解耦和增强系统的可伸缩性、可靠性和灵活性。
👉 下面来看一下常见的 MQ Broker：

|             | `RabbitMQ`                      | `ActiveMQ`                                          | `RocketMQ` | `Kafka`           |
| ----------- | ------------------------------- | --------------------------------------------------- | ---------- | ----------------- |
| **公司 / 社区** | Rabbit                          | Apache                                              | 阿里         | Apache            |
| **开发语言**    | `Erlang`                        | `Java`                                              | `Java`     | `Scala ` & `Java` |
| **协议支持**    | `AMQP`, `XMPP`, `SMTP`, `STOMP` | `OpenWire`, `STOMP`, `REST`, `REST`, `SMPP`, `AMQP` | 自定义协议      | 自定义协议             |
| **可用性**     | 高                               | 一般                                                  | 高          | 高                 |
| **单机吞吐量**   | 一般                              | 差                                                   | 高          | 非常高               |
| **消息延迟**    | 微秒级                             | 毫秒级                                                 | 毫秒级        | 毫秒以内              |
| **消息可靠性**   | 高                               | 一般                                                  | 高          | 一般                |
|             |                                 |                                                     |            |                   |

> 💡 协议：是在通信系统中，用于**规定数据传输格式**、通信规则和通信过程的一组规范。
> 💡 单机吞吐量：单个计算机或服务器上处理的**消息数量或请求数量的度量**。

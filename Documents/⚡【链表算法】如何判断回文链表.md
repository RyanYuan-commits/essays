对应题目，力扣第 234 题「[回文链表](https://leetcode.cn/problems/palindrome-linked-list)」。
给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。
```
输入：head = [1,2,2,1]
输出：true
输入：head = [1,2]
输出：false
```
第一种思路是，通过将链表看做是一个单链的二叉树，递归到达链表终点，此时就可以做到倒序遍历链表了，此时再安排一个指针正序遍历，逐一比较即可。
```java
class Solution {
    ListNode left;
    public boolean isPalindrome(ListNode head) {
        left = head;
        return reverse(head);
    }
    public boolean reverse(ListNode node) {
        if (node == null) return true;
        boolean res = reverse(node.next);
        if (node.val != left.val) {
            return false;
        }
        left = left.next;
        return res;
    }
}
```
# 优化空间复杂度
无论造一条反转链表还是利用后序遍历，算法的时间和空间复杂度都是 O(N)。下面我们想想，能不能不用额外的空间，解决这个问题呢？
可以使用快慢指针先找到链表的中点，然后反转中点后的链表，再与前面的链表比较即可。
```java
ListNode fast = head;
ListNode slow = head;
while (fast != null && fast.next != null) {
	fast = fast.next.next;
	slow = slow.next;
}
if (fast != null) slow = slow.next;
```
如果发现 fast 不是 null，则说明链表有奇数个元素，此时 slow 正好在中间位置，需要后移一位。
```java
class Solution {
    public boolean isPalindrome(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        while (fast != null && fast.next != null) {
            fast = fast.next.next;
            slow = slow.next;
        }
        if (fast != null) slow = slow.next;
        ListNode right = reverse(slow);
        ListNode left = head;
        while (right != null) {
            if (left.val != right.val) {
                return false;
            }
            left = left.next;
            right = right.next;
        }
        return true;
    }
    ListNode reverse(ListNode node) {
        if (node == null || node.next == null) {
            return node;
        }
        ListNode pre = null;
        ListNode cur = node;
        ListNode nxt;
        while (cur.next != null) {
            nxt = cur.next;
            cur.next = pre;
            pre = cur;
            cur = nxt;
        }
        cur.next = pre;
        return cur;
    }
}
```
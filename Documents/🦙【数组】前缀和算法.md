# 一维数组中的前缀和
先来看一道例题，力扣第 303 题「[区域和检索 - 数组不可变](https://leetcode.cn/problems/range-sum-query-immutable)」，让你计算数组区间内元素的和，这是一道非常标准的前缀和问题：
给定一个整数数组  `nums`，处理以下类型的多个查询:
1. 计算索引 `left` 和 `right` （包含 `left` 和 `right`）之间的 `nums` 元素的 **和** ，其中 `left <= right`
实现 `NumArray` 类：
- `NumArray(int[] nums)` 使用数组 `nums` 初始化对象
- `int sumRange(int i, int j)` 返回数组 `nums` 中索引 `left` 和 `right` 之间的元素的 **总和** ，包含 `left` 和 `right` 两点（也就是 `nums[left] + nums[left + 1] + ... + nums[right]` )
本题的测试方式为：
```
NumArray obj = new NumArray(nums);
int param_1 = obj.sumRange(left,right);
```
---
需要注意一下返回的内容是包含 left 和 right 的值的，所以在常规的前缀和之后，还需要加上 left 对应的值。
```java
class NumArray {
    int[] prefix;
    int[] nums;
    public NumArray(int[] nums) {
        this.prefix = new int[nums.length];
        this.nums = nums;
        int sum = 0;
        for (int i = 0; i < nums.length; i++) {
            sum += nums[i];
            prefix[i] = sum;
        }
    }
    public int sumRange(int left, int right) {
        return prefix[right] - prefix[left] + nums[left];
    }
}
```
# 二维数组的前缀和
对应力扣第 304 题「[二维区域和检索 - 矩阵不可变](https://leetcode.cn/problems/range-sum-query-2d-immutable/)」：
给定一个二维矩阵 `matrix`，以下类型的多个请求：
- 计算其子矩形范围内元素的总和，该子矩阵的 **左上角** 为 `(row1, col1)` ，**右下角** 为 `(row2, col2)` 。
实现 `NumMatrix` 类：
- `NumMatrix(int[][] matrix)` 给定整数矩阵 `matrix` 进行初始化
- `int sumRegion(int row1, int col1, int row2, int col2)` 返回 **左上角** `(row1, col1)` 、**右下角** `(row2, col2)` 所描述的子矩阵的元素 **总和** 。
---
任何一个小的区域都可以由下面的这四个矩阵来推导得出。
![[二维数组前缀和.png|800]]
```java
class NumMatrix {
    int[][] prefix;
	    public NumMatrix(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        prefix = new int[m + 1][n + 1];
        for (int i = 1; i <= m; i++) {
            for (int j = 1; j <= n; j++) {
                prefix[i][j] = prefix[i - 1][j] + prefix[i][j - 1] + matrix[i - 1][j - 1] - prefix[i - 1][j - 1];
            }
        }
    }
    public int sumRegion(int row1, int col1, int row2, int col2) {
        return prefix[row2 + 1][col2 + 1] - prefix[row1][col2 + 1] - prefix[row2 + 1][col1] + prefix[row1][col1];
    }
} 
```
---
type: 设计模式
finished: "true"
---

工厂方法模式定义了一个**创建对象的接口**，让子类决定实例化哪个类。

## 使用场景
- **创建对象逻辑简单但需灵活扩展**：当创建对象的逻辑相对简单，不过后续可能需要根据不同条件创建不同类型对象时，工厂方法模式就很适用。例如，在一个图形绘制系统中，根据用户选择的图形类型（圆形、矩形、三角形等）来创建对应的图形对象。每个图形的创建逻辑不复杂，但随着系统的发展，可能会添加新的图形类型，使用工厂方法模式可以方便地扩展新的具体工厂类来创建新图形。
- **需要将对象创建和使用分离**：在一些系统中，对象的创建过程可能比较复杂，或者创建过程可能会发生变化。通过工厂方法模式，将对象的创建逻辑封装在具体工厂类中，使得使用对象的代码只需要调用工厂方法获取对象，而无需关心对象的具体创建过程。这样可以提高代码的可维护性和可测试性。
## 代码案例
```java
// 抽象产品
interface Product {
    void operation();
}

// 具体产品 A
class ConcreteProductA implements Product {
    @Override
    public void operation() {
        System.out.println("ConcreteProductA operation");
    }
}

// 具体产品 B
class ConcreteProductB implements Product {
    @Override
    public void operation() {
        System.out.println("ConcreteProductB operation");
    }
}

// 抽象工厂
abstract class Factory {
    public abstract Product createProduct();
}

// 具体工厂 A
class ConcreteFactoryA extends Factory {
    @Override
    public Product createProduct() {
        return new ConcreteProductA();
    }
}

// 具体工厂 B
class ConcreteFactoryB extends Factory {
    @Override
    public Product createProduct() {
        return new ConcreteProductB();
    }
}

// 测试类
public class FactoryMethodPatternDemo {
    public static void main(String[] args) {
        Factory factoryA = new ConcreteFactoryA();
        Product productA = factoryA.createProduct();
        productA.operation();

        Factory factoryB = new ConcreteFactoryB();
        Product productB = factoryB.createProduct();
        productB.operation();
    }
}
```

## 分析
### 优点
- **灵活性高**：可以通过创建新的具体工厂类来轻松扩展系统，添加新的产品类型。例如，在上述图形绘制系统中，添加新的图形类型只需要创建一个新的具体工厂类即可。
- **符合开闭原则**：对扩展开放，对修改关闭。当需要添加新的产品时，不需要修改现有的代码，只需要添加新的具体工厂类和具体产品类。
- **将对象创建和使用分离**：提高了代码的可维护性和可测试性，使用对象的代码不需要关心对象的具体创建过程。
### 缺点
- **类的数量增加**：随着产品类型的增加，具体工厂类和具体产品类的数量也会相应增加，导致类的数量过多，增加了系统的复杂度。
- **代码重复**：如果每个具体工厂类中创建对象的逻辑有很多重复的部分，会导致代码冗余。
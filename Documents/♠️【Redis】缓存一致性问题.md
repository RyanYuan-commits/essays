### 1 以下的几种方法为什么不行？
#### 1.1 方案一：更新数据库+更新缓存
并发问题的引发都是因为某一个操作有很多步骤，而这些步骤都需要时间，在这些步骤执行的期间被其他线程同样执行这些步骤的线程影响，就出现了并发的问题；对于数据库和缓存的一致性也是这样的问题。
对于更新操作，可以拆分成这样两个步骤：
- 更新数据库
- 更新缓存
对于两个线程 A 和 B 来说，就会出现这四个步骤：
1. A 更新缓存
2. A 更新数据库
3. B 更新缓存
4. B 更新数据库
通过调整先更新数据库还是先更新缓存，我们只能影响其中一个线程的执行顺序，对于两个线程它们进行这些步骤的先后顺序其实是不可预测的，要知道是否会出现并发问题导致数据库和缓存数据不一致，就只需要看上面的步骤排列之后会不会出现问题了。
比如先更新缓存在更新数据库，我们可以举出这样的反例：
1. A 更新缓存（缓存 A）
2. B 更新缓存（缓存 B）
3. B 更新数据库（数据库 B）
4. A 更新数据库（数据库A）
这样就出现了并发中数据不一致的问题；再来看先更新缓存在更新数据库，类似的，也可以举出这样的反例：
1. A 更新数据库（数据库 A）
2. B 更新数据库（数据库 B）
3. B 更新缓存（缓存 B）
4. A 更新缓存（缓存 A）
总结：无论是「先更新数据库，再更新缓存」，还是「先更新缓存，再更新数据库」，这两个方案都存在并发问题，当两个请求并发更新同一条数据的时候，可能会出现缓存和数据库中的数据不一致的现象。
#### 1.2 方案二：先删除缓存再更新数据库
这里我们考虑一个写线程和一个读线程
写线程的操作是这样的：
1. 删除缓存
2. 将值写入数据库
读线程的操作是这样的：
1. 读取数据（假如没有读到）
2. 从数据库中读取数据，写入缓存
此时就出现了并发的问题，当写线程删除缓存，但是还没来得及写入数据库的时候，读线程就已经读取数据并且将内容写入了缓存，此时仍然会出现数据库和缓存数据不一致的问题，步骤是这样的：
1. 线程 A 删除缓存
2. 线程 B 读取缓存（未命中）
3. 线程 B 读取数据库
4. 线程 B 写缓存（缓存旧值）
5. 线程 A 修改数据库（数据库新值）
**先删除缓存，再更新数据库，在「读 + 写」并发的时候，还是会出现缓存和数据库的数据不一致的问题**。
### 2 折中方案：先更新数据库再删除缓存
写线程的操作是这样的：
1. 将值写入数据库
2. 删除缓存
读线程的操作是这样的：
1. 读取数据（假如没有读到）
2. 从数据库中读取数据，写入缓存
如果按照上面的步骤，还是会发生并发导致的不一致问题，假设此时缓存中没有值
1. B 读取缓存（未命中）
2. B 读取数据库
3. A 写入数据库（数据库新值）
4. A 删除缓存
5. B 写入缓存（缓存旧值）
但是这种情况出现的概率非常的小，因为**写缓存的速度比写数据库快的多**，所以 "当 A 写完数据库并且删除完缓存之后，B 才将缓存写入" 的情况出现的概率极低。
---
这种方案的可行是建立在所有的操作都执行成功的情况下的；但是，当某一个操作执行失败，比如 A 删除缓存的操作失败了，会使得用户在缓存没有过期的时间内读取到的都是旧值，也就是用户看到的数据更新时间其实是久于实际的数据库更新时间的。
那如何保证两个步骤都执行成功呢？
有以下的两种方法：
- 重试机制。
- 订阅 MySQL binlog，再操作缓存。
重试机制
我们可以引入**消息队列**，将第二个操作（删除缓存）要操作的数据加入到消息队列，由消费者来操作数据。
- 如果应用**删除缓存失败**，可以从消息队列中重新读取数据，然后再次删除缓存，这个就是**重试机制**。当然，如果重试超过的一定次数，还是没有成功，我们就需要向业务层发送报错信息了。
- 如果**删除缓存成功**，就要把数据从消息队列中移除，避免重复操作，否则就继续重试。
**订阅 MySQL binlog，再操作缓存**
「**先更新数据库，再删缓存**」的策略的第一步是更新数据库，那么更新数据库成功，就会产生一条变更日志，记录在 binlog 里。
于是我们就可以通过订阅 binlog 日志，拿到具体要操作的数据，然后再执行缓存删除，阿里巴巴开源的 Canal 中间件就是基于这个实现的。
Canal 模拟 MySQL 主从复制的交互协议，把自己伪装成一个 MySQL 的从节点，向 MySQL 主节点发送 dump 请求，MySQL 收到请求后，就会开始推送 Binlog 给 Canal，Canal 解析 Binlog 字节流之后，转换为便于读取的结构化数据，供下游程序订阅使用。
![[缓存一致性，订阅 binlog.png]]
所以，如果要想保证「先更新数据库，再删缓存」策略第二个操作能执行成功，我们可以使用「消息队列来重试缓存的删除」，或者「订阅 MySQL binlog 再操作缓存」，这两种方法有一个共同的特点，都是采用异步操作缓存。
### 3 其他
#### 3.1 延迟双删策略
如果我们的业务对缓存命中率有很高的要求，我们可以采用「更新数据库 + 更新缓存」的方案，因为更新缓存并不会出现缓存未命中的情况。
但是这个方案前面我们也分析过，在两个更新请求并发执行的时候，会出现数据不一致的问题，因为更新数据库和更新缓存这两个操作是独立的，而我们又没有对操作做任何并发控制，那么当两个线程并发更新它们的话，就会因为写入顺序的不同造成数据的不一致。
所以我们得增加一些手段来解决这个问题，这里提供两种做法：
- 在更新缓存前先加个**分布式锁**，保证同一时间只运行一个请求更新缓存，就会不会产生并发问题了，当然引入了锁后，对于写入的性能就会带来影响。
- 在更新完缓存时，给缓存加上较短的**过期时间**，这样即时出现缓存不一致的情况，缓存的数据也会很快过期，对业务还是能接受的。
针对「先删除缓存，再更新数据库」方案在「读 + 写」并发请求而造成缓存不一致的解决办法是「**延迟双删**」。
延迟双删实现的伪代码如下：
```java
#删除缓存
redis.delKey(X)
#更新数据库
db.update(X)
#睡眠
Thread.sleep(N)
#再删除缓存
redis.delKey(X)
```
加了个睡眠时间，主要是为了确保请求 A 在睡眠的时候，请求 B 能够在这这一段时间完成「从数据库读取数据，再把缺失的缓存写入缓存」的操作，然后请求 A 睡眠完，再删除缓存。
所以，请求 A 的睡眠时间就需要大于请求 B 「从数据库读取数据 + 写入缓存」的时间。
但是具体睡眠多久其实是个**玄学**，很难评估出来，所以这个方案也只是**尽可能**保证一致性而已，极端情况下，依然也会出现缓存不一致的现象。
因此，还是比较建议用「先更新数据库，再删除缓存」的方案。
```java
public void deleteOrderData(Order order) {
	try(Jedis jedis = RedisUtil.getJedis()) {
		// 线程 A 删除 Redis 缓存
		jedis.del(order.getId() + "");
		
		try {
			// 暂停 2s，其他业务逻辑导致延时耗时
			TimeUnit.SECONDS.sleep(2);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
	} catch(Exception e) {
		e.printStackTrace();
	}
}
```
线程 A sleep 的时间，就需要大于线程 B 读取数据再写入缓存的时间。
这个时间怎么确定呢? 
- 第一种方法： 在业务程序运行的时候，统计下线程读数据和写缓存的操作时间，自行评估自己的项目的读数据业务逻辑的耗时，以此为基础来进行估算。然后写数据的休眠时间则在读数据业务逻辑的耗时基础上加百毫秒即可。 这么做的目的，就是确保读请求结束，写请求可以删除读请求造成的缓存脏数据。 
- 第二种方法： 新启动一个后台监控程序，比如后面要讲解的WatchDog监控程序。
#### 3.2 双重检查锁
双重检查锁是为了避免缓存失效的时候，MySQL 因为承受不了高 QPS 出现宕机的问题来设计的。
它的思路和单例模式实现方式中的双重锁校验完全相同。
如果不使用双重检查锁会出现哪些问题呢？
```java
public String getUserName(Integer userId) {
	String key = userId + "";
	String userName = redisTemplate.opsForValue().get(key);
	if (userName == null) {
		user = userMapper.getUserNameById(userId);
		redisTemplate.opsForValue().setIfAbsent(key, userName, 7L, TimeUnit.HOURS);
	}
	return user;
}
```
当检索缓存发现数据不存在的时候，采取的方案是向数据库中查询；在并发量很小的情况下，MySQL 可以承受，此时可以采取这种写法；
而如果服务的 QPS 很高，超过了 MySQL 的承受上限，就有了宕机的风险。
所以当发现数据缺失的时候，可以只让一个用户去访问数据库，其他用户被阻塞等待。
```java
public String getUserName(Integer userId) {
	String key = userId + "";
	String userName = redisTemplate.opsForValue().get(key);
	if (userName == null) {
		synchronized(UserService.class) {
			userName = redisTemplate.opsForValue().get(key);
			// 再次检查
			if (userName == null) {
				user = userMapper.getUserNameById(userId);
				redisTemplate.opsForValue().setIfAbsent(key, userName, 7L, TimeUnit.HOURS);
			} 
		}
	}
	return user;
}
```
### 4 总结
在大多数业务场景下， 个人建议是，优先使用先更新数据库，再删除缓存的方案(先更库→后删存)。理由如下:
- 先删除缓存值再更新数据库，有可能导致请求因缓存缺失而访问数据库，给数据库带来压力导致打满mysql。
- 如果业务应用中读取数据库和写缓存的时间不好估算，那么，延迟双删中的等待时间就不好设置。
多补充一句：如果使用先更新数据库，再删除缓存的方案，如果业务层要求必须读取一致性的数据，那么我们就需要在更新数据库时，先在 Redis 缓存客户端暂停并发读请求，等数据库更新完、缓存值删除后，再读取数据，从而保证数据一致性，这是理论可以达到的效果，但实际，不推荐，因为真实生产环境中，分布式下很难做到实时一致性，一般都是最终一致性。

| 策略                  | 高并发多线程条件下 | 问题                              | 现象                                      | 解决方案                        |
| ------------------- | --------- | ------------------------------- | --------------------------------------- | --------------------------- |
| 先删除redis缓存，再更新mysql | 无         | 缓存删除成功但数据库更新失败                  | Java程序从数据库中读到旧值                         | 再次更新数据库，重试                  |
|                     | 有         | 缓存删除成功但数据库更新中...  <br>有并发请求     | 并发请求从数据库读到旧值并回写到redis，导致后续都是从redis读取到旧值 | 再次删除缓存，重试                   |
| 先更新mysql，再删除redis缓存 | 无         | 数据库更新成功，但缓存删除失败                 | Java程序从redis中读到旧值                       | 再次删除缓存，重试                   |
|                     | 有         | 数据库更新成功但缓存删除中......  <br>有并发读请求 | 并发请求从缓存读到旧值                             | 等待redis删除完成，这段时间数据不一致，短暂存在。 |

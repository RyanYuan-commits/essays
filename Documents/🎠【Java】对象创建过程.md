![[Java 类的生命周期.png|1000]]
### 1 加载阶段
类加载器根据 **类的全限定名**，通过不同的渠道以二进制流的方式加载字节码信息，例如从本地文件中加载字节码文件、利用动态代理生成的字节码文件、通过网络传输的类等。
当类加载器加载完成类之后，Java 虚拟机会将字节码中的信息保存到内存的方法区中，同时会生成一个 InstanceKlass 对象，保存类的全部信息，其中还包含实现特定的功能，比如实现多态的信息。
在堆中生成一个与方法区中的 InstanceKlass 类似的 java.lang.Class 类型的对象，通过这个对象，我们能够知道这个类的所有属性和方法，并能够调用它的任意一个方法和属性，这也就是反射的基本原理。
### 2 连接阶段
连接阶段可以分为以下的三个具体阶段：
#### 2.1 验证阶段
验证内容是否符合《Java 虚拟机规范》
- 这个阶段是为了验证字节码文件是否符合《Java 虚拟机规范》中的约束，这个阶段一般不需要程序员的参与；
- 一般包含的四个部分，分别是：文件格式的验证、元信息的验证，例如类必须有父类、验证字节码文件执行指令的语义，比如方法中执行到一般突然转到其他方法中、符号引用的验证，例如是否访问了其他类的 private 方法等。
#### 2.2 准备阶段
给静态变量赋初始值，如果是 static 修饰的变量，无论开发者指定了什么值，在这个阶段给它赋值的都是这个类型的初始值，比如 int 就是 0。但是当变量被 final 修饰的时候，会将开发者指定的值赋值给变量。
#### 2.3 解析阶段
将常量池中的符号引用替换为指向内存的直接引用，在解析的阶段会将符号引用转换成内存地址的引用，可以提高访问的速度。
### 3 初始化阶段
#### 3.1 阶段内容
1. 初始化阶段会指定静态代码块中的代码，并且为静态变量赋值。
2. 初始化阶段会执行字节码文件中 clinit 部分的字节码指令，给 static 变量赋值和执行 static 代码块中的方法就是在这个阶段执行的。
```java
public class Main {
    public static int x = 1;
    static {
        x++;
    }
}

0 iconst_1
1 putstatic #7 <org/example/Main.x : I> // 从操作数栈中获取内容，放置到变量中
4 getstatic #7 <org/example/Main.x : I> // 将静态变量放置到操作数栈中
// 这里的自增没有用到 iinc 1 by 1？这个指令是在对局部变量操作的时候使用的
7 iconst_1
8 iadd
9 putstatic #7 <org/example/Main.x : I>
12 return
```
#### 3.2 触发方式
##### 触发案例
以下的几种方式会导致类的初始化：
- 访问一个类的静态变量和静态方法，注意变量是 final 修饰的时候，并不会触发初始化
- 调用 `Class.forName()`
- 通过 new 去创建一个对象的时候
- 执行 main 方法的当前类
```java
public class Main {
    public static void main(String[] args) {
        System.out.println("A");
        new Main();
        new Main();
    }
    public Main() {
        System.out.println("B");
    }
    {
        System.out.println("C");
    }
    static {
        System.out.println("D");
    }
}
```
输出的顺序 DACBCB
首先执行 main 方法的类需要被加载，执行静态代码块中的方法，然后执行 main 方法中的部分，非静态代码块会在每次创建类的时候，在构造方法之前执行，所以每次创建类的时候都会输出 CB。
##### 常见误区
- 直接访问父类的静态变量，不会触发子类的初始化
- 子类的初始化 clinit 调用之前，会优先调用父类的 clinit 方法
```java
public class Main {
    public static void main(String[] args) {
        B b = new B(); // 实例化 b，需要执行初始化阶段
        System.out.println(B.a); // 10
    }
}
class A {
    static int a = 0;
    static {
        a = 1;
        System.out.println("父类的静态代码块");
    }
}

class B extends A {
    static {
        a = 10;
    }
}
```
而将 `B b = new B();` 去掉之后，就会直接访问父类的变量此时输出的是 1。
### 4 实例化阶段
#### 4.1 分配内存
假设Java堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。
但如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。
#### 4.1.2 并发下的分配安全
除如何划分可用空间之外，还有另外一个需要考虑的问题：对象创建在虚拟机中是非常频繁的行为，在并发状态下如何保证内存分配的安全性呢？
可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案：
1. **对分配内存空间的动作进行同步处理** —— 实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性
2. **分配的动作按照线程划分在不同的空间之中进行**，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local AllocationBuffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。 虚拟机是否使用TLAB，可以通过 `-XX：+/-UseTLAB` 参数来设定。
#### 4.2 对象设置
内存分配完成之后，虚拟机必须将分配到的内存空间（但不包括对象头）都初始化为零值，接下来，Java虚拟机还要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用 `Object::hashCode()` 方法时才计算）、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。
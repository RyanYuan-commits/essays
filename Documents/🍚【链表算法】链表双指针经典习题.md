# 删除排序链表中的重复元素
给定一个已排序的链表的头 `head` ， 删除原始链表中所有重复数字的节点，只留下不同的数字。返回已排序的链表 。
```
例如：
输入：head = [1,2,3,3,4,4,5]
输出：[1,2,5]
```
为了避免头节点的干扰，本题需要使用虚拟头节点。
![[删除排序链表中的重复元素]]
我们让指针 cursor 总是指向不会重复的那个节点，然后通过循环去检测这个节点后面是否出现了重复的节点。
也就是不断检测当前节点的 value 值 和 p.next 的 value 值，如果相同就记录个数，此时就会有两种情况
- cursor 指针后面的节点是重复节点，此时 p 指向的就是这个节点的后一个节点，此时直接让 cursor.next = p 即可
- cursor 指针后面的节点不是重复节点，那 cursor 就应该指向下一个不重复的节点，也就是 cursor = cursor.next
```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        ListNode dummy = new ListNode();
        dummy.next = head;
        ListNode cursor = dummy;
        while (cursor.next != null) {
            int val = cursor.next.val;
            ListNode p = cursor.next;
            int num = 0;
            while (p != null && p.val == val) {
                num++;
                p = p.next;
            }
            if (num > 1) {
                cursor.next = p;
            } else {
                cursor = cursor.next;
            }
        }
        return dummy.next;
    }
}
```
第二种思路是通过递归，我们规定递归函数的输入是一个节点，返回的是这个节点去重后得到的节点：
```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null || head.next == null) {
            return head;
        }
        if (head.val != head.next.val) {
	        // 对后面的节点进行去重即可
            head.next = deleteDuplicates(head.next);
            return head;
        }
        int value = head.val;
        // 找到第一个该节点不同的节点
        while (head != null && head.val == value) {
            head = head.next;
        }
        return deleteDuplicates(head);
    }
}
```

### 1 为什么需要主从？
由于数据都是存储在一台服务器上，如果出事就完犊子了，比如：
- 如果服务器发生了宕机，由于数据恢复是需要点时间，那么这个期间是无法服务新的请求的；
- 如果这台服务器的硬盘出现了故障，可能数据就都丢失了。
要避免这种单点故障，最好的办法是将数据备份到其他服务器上，让这些服务器也可以对外提供服务，这样即使有一台服务器出现了故障，其他服务器依然可以继续提供服务。
### 2 主从配置
使用 `replicaof` 命令形成主服务器和从服务器的关系。
现在有服务器 A 和 服务器 B，我们在服务器 B 上执行下面这条命令：
```
# 服务器 B 执行这条命令
replicaof <服务器 A 的 IP 地址> <服务器 A 的 Redis 端口号>
```
接着，服务器 B 就会变成服务器 A 的「从服务器」，然后与主服务器进行第一次同步。
### 3 第一次同步
主从服务器间的第一次同步的过程可分为三个阶段：
- 第一阶段是建立链接、协商同步；
- 第二阶段是主服务器同步数据给从服务器；
- 第三阶段是主服务器发送新写操作命令给从服务器。
![[Redis 主从复制流程.png]]
### 3 命令传播
主从服务器在完成第一次同步后，双方之间就会维护一个 TCP 连接。
后续主服务器可以通过这个连接继续将写操作命令传播给从服务器，然后从服务器执行该命令，使得与主服务器的数据库状态相同。
而且这个连接是长连接的，目的是避免频繁的 TCP 连接和断开带来的性能开销。
上面的这个过程被称为**基于长连接的命令传播**，通过这种方式来保证第一次同步后的主从服务器的数据一致性。
### 4 分摊主服务器的压力
#### 4.1 从服务器负责数据同步
主从服务器在第一次数据同步的过程中，主服务器会做两件耗时的操作：生成 RDB 文件和传输 RDB 文件。主服务器是可以有多个从服务器的，如果从服务器数量非常多，而且都与主服务器进行全量同步的话，就会带来两个问题：
- 由于是通过 bgsave 命令来生成 RDB 文件的，那么主服务器就会忙于使用 fork() 创建子进程，如果主服务器的内存数据非大，在执行 fork() 函数时是会阻塞主线程的，从而使得 Redis 无法正常处理请求；
- 传输 RDB 文件会占用主服务器的网络带宽，会对主服务器响应命令请求产生影响。
![[Redis 从服务器分担主服务器压力.png|800]]
通过这种方式，**主服务器生成 RDB 和传输 RDB 的压力可以分摊到充当经理角色的从服务器**。
#### 4.2 如何实现？
其实很简单，我们在「从服务器」上执行下面这条命令，使其作为目标服务器的从服务器：
```c
replicaof <目标服务器的IP> 6379
```
此时如果目标服务器本身也是「从服务器」，那么该目标服务器就会成为「经理」的角色，不仅可以接受主服务器同步的数据，也会把数据同步给自己旗下的从服务器，从而减轻主服务器的负担。
### 5 增量复制
#### 5.1 增量复制是如何实现的？
如果主从服务器间的网络连接断开了，同步无法进行，当网络恢复的时候，如何重新同步呢？
![[Redis 主从增量复制.png|600]]
主要有三个步骤：
- 从服务器在恢复网络后，会发送 `psync` 命令给主服务器，此时的 `psync` 命令里的 `offset` 参数不是 -1；
- 主服务器收到该命令后，然后用 `CONTINUE` 响应命令告诉从服务器接下来采用增量复制的方式同步数据；
- 然后主服务将主从服务器断线期间，所执行的写命令发送给从服务器，然后从服务器执行这些命令。
Redis 通过一个环形缓冲区来解决需要将哪些数据发送给从服务器的问题：
- **repl_backlog_buffer**，是一个「**环形**」缓冲区，用于主从服务器断连后，从中找到差异的数据；
- **replication offset**，标记上面那个缓冲区的同步进度，主从服务器都有各自的偏移量，主服务器使用 `master_repl_offset` 来记录自己「写」到的位置，从服务器使用 `slave_repl_offset` 来记录自己「读」到的位置。
在主服务器进行命令传播时，不仅会将写命令发送给从服务器，还会将写命令写入到 `repl_backlog_buffer` 缓冲区里，因此缓冲区里会保存着最近传播的写命令。
#### 5.2 缓冲区大小如何配置？
`repl_backlog_buffer` 缓行缓冲区的默认大小是 1M，并且由于它是一个环形缓冲区，所以当缓冲区写满后，主服务器继续写入的话，就会覆盖之前的数据。因此，当主服务器的写入速度远超于从服务器的读取速度，缓冲区的数据一下就会被覆盖。
那么在网络恢复时，如果从服务器想读的数据已经被覆盖了，主服务器就会采用全量同步，这个方式比增量同步的性能损耗要大很多。
因此，为了避免在网络恢复时，主服务器频繁地使用全量同步的方式，我们应该调整下 `repl_backlog_buffer` 缓冲区大小，尽可能的大一些，减少出现从服务器要读取的数据被覆盖的概率，从而使得主服务器采用全量同步的方式。
可以参考这个公式来配置 $second * write\_size\_per\_second$
- `second` 为从服务器断线后重新连接上主服务器所需的平均 时间(以秒计算)。
- `write_size_per_second` 则是主服务器平均每秒产生的写命令数据量大小。
这个值可以直接在 `redis.conf` 文件中配置
```c
repl-backlog-size 1mb
```
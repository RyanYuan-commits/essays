行级锁加锁规则比较复杂，不同的场景，加锁的形式是不同的。**加锁的对象是索引，加锁的基本单位是临键锁**。
### 1 唯一索引等值查询
当使用唯一索引进行等值查询时，根据查询的记录是否存在，加锁的规则也会不同，如果退化的锁就已经可以解决幻读的情况，就会发生锁退化：
- 当查询的记录是「存在」的，在索引树上定位到这一条记录后，将该记录的索引中的 next-key lock 会 **退化成「记录锁」**。
- 当查询的记录是「不存在」的，在索引树找到第一条大于该查询记录的记录后，将该记录的索引中的 next-key lock 会 **退化成「间隙锁」**。
#### 1.1 记录存在的情况
比如事务 A 执行了这样的语句，并且表中的数据是存在的，此时执行的事务 B 会被阻塞。
```sql
-- 事务 A
BEGIN;
SELECT * FROM user_0 WHERE id = 1 FOR UPDATE;

-- 事务 B
BEGIN;
UPDATE user_0 SET age = 19 WHERE id = 1;
```

可以通过这个语句来查看事务过程中都加了什么锁：
```sql
select * from performance_schema.data_locks;
```

| 列                     | Line1                                | Line2                                  |
| --------------------- | ------------------------------------ | -------------------------------------- |
| ENGINE                | InnoDB                               | InnoDB                                 |
| ENGINE_LOCK_ID        | 281473082985688:1076:281473097716656 | 281473082985688:10:4:2:281473097713664 |
| ENGINE_TRANSACTION_ID | 33306                                | 33306                                  |
| THREAD_ID             | 48                                   | 48                                     |
| EVENT_ID              | 52                                   | 52                                     |
| OBJECT_SCHEMA         | user_db                              | user_db                                |
| OBJECT_NAME           | user_0                               | user_0                                 |
| PARTITION_NAME        | 无                                    | 无                                      |
| SUBPARTITION_NAME     | 无                                    | 无                                      |
| INDEX_NAME            | 281473097716656                      | PRIMARY                                |
| OBJECT_INSTANCE_BEGIN | 281473097716656                      | 281473097713664                        |
| LOCK_TYPE             | **TABLE**                            | **RECORD**                             |
| LOCK_MODE             | IX                                   | X,REC_NOT_GAP                          |
| LOCK_STATUS           | GRANTED                              | GRANTED                                |
| LOCK_DATA             | 无                                    | 1                                      |
查询出来的语句锁这样的，锁类型分别是表锁和记录，表锁上加的是一个意向排他锁（IX）；
记录锁上加的是一个排他锁（X），且是一个记录锁（RECORD NOT GAP）。
- 如果 LOCK_MODE 为 `X`，说明是 next-key 锁
- 如果 LOCK_MODE 为 `X, REC_NOT_GAP`，说明是记录锁
- 如果 LOCK_MODE 为 `X, GAP`，说明是间隙锁
从上面的数据中，可以看出，此时加的是记录锁，这是因为，在这种情况下，记录锁已经完全可以保证不会出现幻读的现象了。
幻读的定义就是，当一个事务前后两次查询的结果集，不相同时，就认为发生幻读，此时给索引 1 加上锁，就可以保证新的索引为 1 的值不会被插入，而原本的索引值为 1 的数据也不会被删除了。
#### 2.2 记录不存在的情况
表中的数据是这样的：
![[唯一索引等值查询记录不存在的情况.png|500]]

比如，此时我们需要查询索引值为 4 的数据，那肯定是无法查询到的，此时的加锁情况锁这样的：

| 列                     | Line2                                | Line2                                  |
| --------------------- | ------------------------------------ | -------------------------------------- |
| ENGINE                | InnoDB                               | InnoDB                                 |
| ENGINE_LOCK_ID        | 281473082985688:1076:281473097716656 | 281473082985688:10:4:5:281473097713664 |
| ENGINE_TRANSACTION_ID | 33308                                | 33308                                  |
| THREAD_ID             | 48                                   | 48                                     |
| EVENT_ID              | 55                                   | 55                                     |
| OBJECT_SCHEMA         | user_db                              | user_db                                |
| OBJECT_NAME           | user_0                               | user_0                                 |
| PARTITION_NAME        | 无                                    | 无                                      |
| SUBPARTITION_NAME     | 无                                    | 无                                      |
| INDEX_NAME            | 281473097716656                      | PRIMARY                                |
| OBJECT_INSTANCE_BEGIN | 281473097716656                      | 281473097713664                        |
| LOCK_TYPE             | TABLE                                | RECORD                                 |
| LOCK_MODE             | IX                                   | X,GAP                                  |
| LOCK_STATUS           | GRANTED                              | GRANTED                                |
| LOCK_DATA             | 无                                    | 5                                      |

从上图可以看到，共加了两个锁，分别是：X 类型的意向锁（表锁） 、X 类型的间隙锁（行锁）。
此时我们去修改其他 id 的数据都是没有问题的，可以推断出，此时加的是 (3, 5) 这个范围的间隙锁；当然，添加 id 为 4 的数据会被阻塞。
### 2 唯一索引范围查询
#### 2.1 大于案例
会对每一个扫描到的索引加 next-key 锁，然后有一些，会退化成记录锁或者间隙锁。
我们来尝试一下自己推导加锁的逻辑：在以下的限制条件下，为了避免幻读情况的发生，应该怎样加锁呢？
1. 限制一：锁只能加在索引上，但是有三种锁可以选择：记录锁、间隙锁、临键锁。
2. 限制二：尽量使用间隙锁和记录锁。

![[唯一索引范围查询加锁情况表数据.png|400]]
```sql
SELECT * FROM user WHERE id > 5 FOR UPDATE;
```
此时查询到的第一个索引为 10，而为了避免幻读，`(5, 10)` 这个范围内是不应该有数据的，且索引为 10 的数据也不能被修改，此时加的就是 `(5, 10]` 的临键锁。
下一个扫描到的数据是表的结束记录，在 `Innodb` 中，这个记录叫做 `supremum pseudo-record`；此时为了避免幻读，需要锁定的就是从 10 往后的所有数据，也就是 `(10, +∞]` 的临键锁。
#### 2.2 大于等于案例
再来看一个案例，此时的查询语句为：
```sql
SELECT * FROM user WHERE id >= 5 FOR UPDATE;
```
第一个遍历到是索引为 5 的数据，为了避免幻读，就需要保证索引为 5 的数据不会被删除或者修改索引，此时就需要给索引 5 加上记录锁。
然后遍历到索引为 10 的数据，此时有需要保证 `(5, 10)` 这个范围内数据不能被修改，同时索引为 10 的记录也不能被修改，此时只需要加上 `(5, 10]` 的临键锁即可
最后就和上面的情况一样，加上  `(10, +∞]` 的临键锁。
#### 2.3 小于案例
![[索引范围查询小于且记录不存在的情况.png|400]]
```sql
select * from user where id < 6 for update;
```
首先遍历到的是索引 1（从开头开始查找的），要保证索引 1 不能被修改，且索引 1 前不能添加数据，此时需要的就是 `[-∞, 1]` 的临键锁。
然后扫描的是索引 2 的时候，此时要保证 `(1, 2)` 不能添加数据，且 2 不能被修改，要添加的就是 `(1, 2]` 的临键锁。同样，扫描到 3 的时候，加的就是 (2, 3]。
然后下一个索引是 5（4 记录不存在），加的是 `(3, 5]` 的临键锁，到最后遍历到 10 的时候，加的就是 `(5, 10)` 的间隙锁了。
#### 2.4 小于等于案例
![[唯一索引范围查询记录存在的情况.png|400]]
```sql
SELECT * FROM user WHERE id <= 10 FOR UPDATE;
```
此时与上面不同的是，10 这个位置的间隙锁变成了 `(5, 10]` 的临键锁。
### 3 二级索引等值查询
#### 3.1 记录存在
当我们用非唯一索引进行等值查询的时候，因为存在两个索引，一个是主键索引，一个是非唯一索引（二级索引），所以在加锁时，同时会对这两个索引都加锁，但是对主键索引加锁的时候，只有满足查询条件的记录才会对它们的主键索引加锁。
![[二级索引表数据.png]]
先来说说非唯一索引等值查询时，查询的记录不存在的情况，因为这个比较简单。假设事务 A 对非唯一索引（age）进行了等值查询，且表中不存在 age = 25 的记录。
```sql
begin;
select * from user where age = 20 for update;
```
定位到第一条不符合查询条件的二级索引记录，即扫描到 `age = 39`，于是该二级索引的 `next-key` 锁会退化成间隙锁，范围是 `(22, 39)`。
![[二级索引等值查询数据存在.png]]
#### 3.2 记录不存在
```sql
begin;
select * from user where age = 21 for update;
```
![[二级索引等值查询记录存在.png|900]]
此时锁定的就是 `(19, 21]` 的临键锁，加上 `(21, +∞)` 的间隙锁，除此之外，还这条记录对应的 id 索引上加上了记录锁，保证这条记录的其他列不会被修改。
### 4 二级索引范围查询
二级索引和主键索引的范围查询的加锁也有所不同，对于「非唯一索引范围查询」，索引的临键锁不会有退化为间隙锁和记录锁的情况，也就是非唯一索引进行范围查询时，对二级索引记录加锁都是加 `next-key` 锁。
![[二级索引表数据.png]]
比如执行这条语句：
```sql
BEGIN;
select * from user_0 where age >= 19 for update;
```
![[二级索引范围查询且记录存在.png|900]]
当记录存在的时候，会为存在的记录加上主键锁，来保证他们不会被修改，也就是下面几个 `PRIMIARY` 锁，上面的几个都是间隙锁，保证了在这个范围内都不会有数据插入。
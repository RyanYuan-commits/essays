# 项目结构
- 项目代码：[https://github.com/KkQ36/dynamic-thread-pool](https://github.com/KkQ36/dynamic-thread-pool)
- 分支：main
>[!info] dynamic-thread-pool-starter
```
├── dynamic-thread-pool-starter
│   ├── pom.xml
│   └── src
│       ├── main
│       │   ├── java
│       │   │   └── com
│       │   │       └── ryan
│       │   │           └── sdk
│       │   │               ├── config
│       │   │               │   ├── DynamicThreadPoolAutoConfig.java
│       │   │               │   └── DynamicThreadPoolAutoProperties.java
│       │   │               ├── domain
│       │   │               │   └── pool
│       │   │               │       ├── commons
│       │   │               │       │   └── RegistryEnums.java
│       │   │               │       ├── model
│       │   │               │       │   └── entity
│       │   │               │       │       └── ThreadPoolConfigEntity.java
│       │   │               │       └── service
│       │   │               │           ├── DynamicThreadPoolService.java
│       │   │               │           └── IDynamicThreadPoolService.java
│       │   │               ├── registry
│       │   │               │   ├── IRegistry.java
│       │   │               │   └── redis
│       │   │               │       └── RedisRegistry.java
│       │   │               └── trigger
│       │   │                   ├── job
│       │   │                   │   ├── IJob.java
│       │   │                   │   └── SpringScheduledJobHandler.java
│       │   │                   └── listener
│       │   │                       └── ThreadPoolConfigAdjustListener.java
│       │   └── resources
│       │       └── META-INF
│       │           └── spring.factories
│       └── test
│           └── java
```
# 要点记录
## Redisson 的订阅与发布
Redisson 的 RTopic 是基于 Redis 的发布/订阅（pub/sub）机制实现的。它允许你在 Redis 频道上发布消息，并让订阅者接收这些消息。
>[!info] com.ryan.sdk.trigger.listener.ThreadPoolConfigAdjustListener
>准备一个 Listener 定义处理逻辑
```java
public class ThreadPoolConfigAdjustListener implements MessageListener<ThreadPoolConfigEntity> {  
    private final IDynamicThreadPoolService dynamicThreadPoolService;  
    private final IRegistry registry;  
    public ThreadPoolConfigAdjustListener(IDynamicThreadPoolService dynamicThreadPoolService, IRegistry registry) {  
        this.dynamicThreadPoolService = dynamicThreadPoolService;  
        this.registry = registry;  
    }  
    @Override  
    public void onMessage(CharSequence channel, ThreadPoolConfigEntity threadPoolConfigEntity) {  
        // 更新线程池状态
    }  
}
```
>[!info] com.ryan.sdk.config.DynamicThreadPoolAutoConfig
>将监听绑定到 Topic 上
```java
@Slf4j  
@Configuration  
@EnableScheduling  
@EnableConfigurationProperties(DynamicThreadPoolAutoProperties.class)
public class DynamicThreadPoolAutoConfig {  
    @Bean  
    public ThreadPoolConfigAdjustListener threadPoolConfigAdjustListener(IDynamicThreadPoolService dynamicThreadPoolService, IRegistry registry) {  
        return new ThreadPoolConfigAdjustListener(dynamicThreadPoolService, registry);  
    }  
    @Bean(name = "dynamicThreadPoolRedisTopic")  
    public RTopic dynamicThreadPoolRedisTopic(RedissonClient redissonClient, ThreadPoolConfigAdjustListener threadPoolConfigAdjustListener) {  
        String topicName = RegistryEnums.DYNAMIC_THREAD_POOL_REDIS_TOPIC.getKey() + "_" + applicationName;  
        RTopic topic = redissonClient.getTopic(topicName);  
        topic.addListener(ThreadPoolConfigEntity.class, threadPoolConfigAdjustListener);  
        log.info("动态线程池，启动提示。监听主题：{}", topicName);  
        return topic;  
    }  
}
```
# 核心代码
>[!info] com.ryan.sdk.domain.pool.service.DynamicThreadPoolService
> 更新线程池的方法，设置线程池的核心线程数和
```java
package com.ryan.sdk.domain.pool.service;  
public class DynamicThreadPoolService implements IDynamicThreadPoolService {  
    @Override  
    public void updateThreadPoolConfig(ThreadPoolConfigEntity threadPoolConfigEntity) {  
        // 入参检测  
        String threadPoolName = threadPoolConfigEntity.getThreadPoolName();  
        if (!threadPoolExecutorMap.containsKey(threadPoolName)) {  
            log.error("应用{}：不存在名为 {} 的线程池 ", applicationName, threadPoolName);  
            return;  
        }  
        if (threadPoolConfigEntity.getCorePoolSize() > threadPoolConfigEntity.getMaximumPoolSize()) {  
            log.error("核心线程数不能大于最大线程数");  
            return;  
        }  
        // 修改数据  
        ThreadPoolExecutor threadPoolExecutor = threadPoolExecutorMap.get(threadPoolName);  
        threadPoolExecutor.setCorePoolSize(threadPoolConfigEntity.getCorePoolSize());  
        threadPoolExecutor.setMaximumPoolSize(threadPoolConfigEntity.getMaximumPoolSize());  
        log.info("修改线程池 {} 配置成功", threadPoolName);  
    }  
}
```



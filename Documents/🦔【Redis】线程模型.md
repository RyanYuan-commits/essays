### 1 为什么说 Redis 是单线程？
主要是指过去 Redis 的网络 IO 和 **键值对读写** 是通过一个线程来完成的，Redis 在处理客户端请求的时候，比如 socket 读、解析、执行、socket 写，都是由一个顺序的、串行的主线程来处理的，这就是所谓的单线程。
但是 Redis 的其他功能，比如 RDB、AOP、异步删除、集群数据同步等等，是通过子进程来完成的。
在官方文档的中的，How can Redis use multiple CPUs or cores? 提到：
It's not very frequent that CPU becomes your bottleneck with Redis, as usually Redis is either memory or network bound.
CPU 成为 Redis 性能瓶颈的情况非常少见，通常 Redis 的性能瓶颈通常是由内存和网络带来的。
### 2 Redis 为什么快？
1. 基于内存实现：Redis 的所有数据都存储在内存中，运算都是内存级别，所以性能比较高。
2. 数据结构简单：Redis 都数据结构是专门设计的，这些简单的数据结构查找和操作的时间大部分的时间复杂度都是 O(1)。
3. 多路复用和非阻塞 I/O：Redis 使用 I/O 多路服用技术来监听多个 Socket 链接客户端，这样就能使用一个线程来处理多个请求，减少线程切换带来的影响。
4. 避免上下文切换：避免了上下文切换和多线程竞争，省去了多线程切换带来的时间和性能上的损耗。
### 3 为什么说 Redis 6、7 引入了多线程
Redis 的瓶颈后来被定为网络 IO，在 Redis 6 和 7 中，非常受关注的一个新特性就是多线程，这是因为，Redis一直被大家熟知的就是它的单线程架构，虽然有些命令操作可以用后台线程或子进程执行（比如数据删除、快照生成、AOF重写）但是，从网络IO处理到实际的读写命令处理，都是由单个线程完成的。随着网络硬件的性能提升，Redis的性能瓶颈有时会出现在网络 I/O 的处理上，也就是说，单个主线程处理网络请求的速度跟不上底层网络硬件的速度，为了应对这个问题：Redis 采用多个 IO 线程来处理网络请求，提高网络请求处理的并行度。
但是，**Redis 的多 IO 线程只是用来处理网络请求的**，对于读写操作命今Redis仍然使用单线程来处理。这是因为，Redis 处理请求时，网络处理经常是瓶颈，通过多个 IO 线程并行处理网络操作，可以提升实例的整体处理性能。而继续使用单线程执行命今换作，就不用为了保证 Lua 脚本、事务的原子性，额外开发多线程互斥加锁机制了(不管加锁操作处理)，这样一来，Redis 线程模型实现就简单了。
### 4 主线程和 IO 线程是如何协作来处理请求的？
- **服务端和客户端建立 Socket 链接，并分配处理线程**：主线程负责接收建立连接的请求，当有客户端请求和实例建立 Socket 连接的时候，主线程会创建和客户端的连接，并且将 Socket 放入全局阻塞队列中，然后主线程通过轮询的方法，将 Socket 分给 IO 线程。
- **IO  线程读取并解析请求**：主线程把 Socket 分配给 IO 线程，自身就会进入阻塞状态，等待 IO 线程将客户端的请求读取和解析完成，因为有多个 IO 线程并行的进行，所以这些操作很快就可以完成。
- **主线程执行请求操作**：等到 IO 线程解析完请求，主线程还是以单线程的方式执行这些命令操作。
- **IO 线程回写 Socket 和主线程清空全局队列**：当主线程执行完操作之后，会把需要返回的结果存入缓冲区，然后，主线程回阻塞等待 IO 线程将这些结果写到 Socket 中，并且返回给客户端，和 IO 读取请求一样，IO 回写 Socket 的时候也是多个线程在执行，等到 IO 线程回写 Socket 完毕，主线程会清空全局队列，等待客户端的后续请求。
### 5 开启多线程功能
Redis 6 和 7 的多线程机制默认是被关闭的，如果出现了系统 CPU 负荷不高，但是吞吐量上不去的时候，可以开启多线程机制，需要在 `redis.conf` 中完成这两个设置：
```
io-threads 4
io-threads-do-reads no
```
上面两个配置都是默认被注释的
- `io-threads` 配置的是处理网络 I/O 的线程个数
- `io-threads-do-reads` 控制这些线程是否执行读操作，不开启的话，线程只会负责将数据写回 Socket，而不会进行读取请求和协议解析。如果系统的读取压力不大但写入量较大可以不用开启。
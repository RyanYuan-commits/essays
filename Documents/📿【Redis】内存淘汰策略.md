### 1 触发时机
在 Redis 配置文件中，可以通过参数 `maxmemory` 来设定 Redis 的最大运行内存，只有在运行内存达到配置的最大运行内存，才会触发内存淘汰策略。
- 在 64 位操作系统中，maxmemory 的默认值是 0，表示没有内存大小限制，那么不管用户存放多少数据到 Redis 中，Redis 也不会对可用内存进行检查，直到 Redis 实例因内存不足而崩溃也无作为。
- 在 32 位操作系统中，maxmemory 的默认值是 3G，因为 32 位的机器最大只支持 4GB 的内存，而系统本身就需要一定的内存资源来支持运行，所以 32 位操作系统限制最大 3 GB 的可用内存是非常合理的，这样可以避免因为内存不足而导致 Redis 实例崩溃。
如果配置内存淘汰策略为 `noeviction`(3.0 后，默认的内存淘汰策略)，当内存超过最大内存后再写入会报错禁止写入，读取和删除功能正常。
### 2 可用的内存淘汰策略
通过 `config set maxmemory-policy <策略>` 命令或者配置文件中的 `maxmemory-policy <策略>` 选项可以配置内存淘汰策略。
Redis 提供了如下的内存淘汰策略：
#### 2.1 选择设置了过期时间的键
- **volatile-random**：随机淘汰设置了过期时间的任意键值；
- **volatile-ttl**：优先淘汰更早过期的键值。
- **volatile-lru**（Redis3.0 之前，默认的内存淘汰策略）：淘汰所有设置了过期时间的键值中最近最少使用的键值，关注的是最晚使用时间；
- **volatile-lfu**（Redis 4.0 后新增的内存淘汰策略）：淘汰所有设置了过期时间的键值中最近最不常用键值，关注的是使用的频率。
#### 2.2 全局范围选择
- **allkeys-random**：随机淘汰任意键值;
- **allkeys-lru**：淘汰整个键值中最近最少使用的键值，关注的是最晚使用时间；
- **allkeys-lfu**（4.0 后新增的内存淘汰策略）：淘汰整个键值中最近最不常用的键值，关注的是使用的频率。
### 2 LRU 与 LFU
#### 2.1 LRU 算法
##### 常规的 LRU 算法有什么问题？
**LRU** 全称是 Least Recently Used 翻译为**最近最少使用**，会选择淘汰最近最少使用的数据。
传统 LRU 算法的实现是基于「链表」结构，链表中的元素按照操作顺序从前往后排列，最新操作的键会被移动到表头，当需要内存淘汰时，只需要删除链表尾部的元素即可，因为链表尾部的元素就代表最久未被使用的元素。但是，传统的 LRU 算法存在两个问题，Redis 并没有使用传统的 LRU 算法。
- 需要用链表管理所有的缓存数据，这会带来额外的空间开销；
- 当有数据被访问时，需要在链表上把该数据移动到头端，如果有大量数据被访问，移动链表带来的耗时比较久，会降低 Redis 缓存性能。
#### Redis 是如何实现 LRU 算法的？
Redis 实现的是一种**近似 LRU 算法**，目的是为了更好的节约内存，它的实现方式是在 Redis 的对象结构体中添加一个额外的字段，用于记录此数据的最后一次访问时间。
当 Redis 进行内存淘汰时，会使用**随机采样的方式来淘汰数据**，它是随机取 5 个值（此值可配置），然后**淘汰最久没有使用的那个**。
Redis 实现的 LRU 算法的优点：
- 不用为所有的数据维护一个大链表，节省了空间占用；
- 不用在每次数据访问时都移动链表项，提升了缓存的性能；
但是 LRU 算法有一个问题，**无法解决缓存污染问题**，比如应用一次读取了大量的数据，而这些数据只会被读取这一次，那么这些数据会留存在 Redis 缓存中很长一段时间，造成缓存污染，因此，在 Redis 4.0 之后引入了 LFU 算法来解决这个问题。
#### 2.2 LFU 算法
##### 什么是 LFU 算法？
LFU 全称是 Least Frequently Used 翻译为最近最不常用，LFU 算法是根据数据访问次数来淘汰数据的，它的核心思想是“如果数据过去被访问多次，那么将来被访问的频率也更高”。
所以， LFU 算法会记录每个数据的访问次数。当一个数据被再次访问时，就会增加该数据的访问次数。这样就解决了偶尔被访问一次之后，数据留存在缓存中很长一段时间的问题，相比于 LRU 算法也更合理一些。
##### Redis 是如何实现 LFU 算法的？
LFU 算法根据的是访问的频次，为了计算这个频次，还需要记录最近一次访问的时间，在 key 被访问的时候，会根据这个最近一次访问的时间来对 key 的访问频次进行惰性的动态调整；控制衰减速率的重要参数是 `lfu-decay-time`，单位为分钟，这个值越小衰减的就越快，默认的 `lfu-decay-time` 为 1，也就是每隔一分钟，redis 就会在逻辑上衰减 key 的访问频次，真实的衰减其实还是发生在访问的时候，是一个惰性的衰减。
![[Redis LFU 算法实现方式.png|center|800]]
在 LFU 算法中，Redis对象头的 24 bits 的 `lru` 字段被分成两段来存储，高 16bit 存储 key 最近一次访问的时间戳，低 8bit 存储 key 的访问频次，它的值越小表示使用频率越低，越容易淘汰，每个新加入的 key 的logc 初始值为 5。
## 1 根节点枚举

固定可作为 GC Roots 的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如 栈帧中的本地变量表）中，尽管目标明确，但查找过程要做到高效并非一件容易的事情，如何在 **垃圾回收期间如何快速准确定位对象引用** 成为了一个迫切需要结局的问题。

迄今为止，所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的，因此毫无疑问根节点枚举与之前提及的整理内存碎片一样会面临相似的 “Stop The World” 的困扰。

当用户线程停顿下来之后，其实并不需要一个不漏地检查完所有执行上下文和全局的引用位置，**虚拟机应当是有办法直接得到哪些地方存放着对象引用的**。

在 HotSpot 的解决方案里，是使用一组称为 OopMap 的数据结构来达到这个目的。

>[!define]
>OopMap 是一种在 HotSpot JVM 中使用的特殊数据结构，它记录了在 **特定时刻**（例如，GC 发生时），栈帧中（或寄存器中）哪些位置保存的是 “**对象引用 (Ordinary Object Pointer - Oop)**”。

一旦类加载动作完成的时候， HotSpot 就会把对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，也会在特定的位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接得知这些信息了，并不需要真正一个不漏地从方法区等位置从头开始查找。

## 2 安全点
### 2.1 简介

在 OopMap 的协助下，HotSpot 可以快速准确地完成 GC Roots 枚举，但一个很现实的问题随之而来: **可能导致引用关系变化，或者说导致 OopMap 内容变化的指令非常多**；

如果为每一条指令都生成对应的 OopMap ，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。

实际上 HotSpot 也的确没有为每条指令都生成 OopMap，而是记录了某些特定位置的引用信息，这些位置被称为安全点 (Safe point)，当需要执行 GC 的时候，只需要让所有执行代码的线程都进入安全点，就可以利用为这个安全点创建的 OopMap 来辅助 GC 了。

JVM 在选择安全点位置时，不会考虑指令的“长度”，因为单条机器指令的执行时间都非常短。指令流本身长短不重要，重要的是 **执行这条指令流需要多长时间**；

JVM 更关注那些 可能导致线程长时间运行而不进行状态更新（即长时间不进入安全点）的代码段。而这种“长时间执行”最普遍、最明显的特征就是代码的 “重复执行”，尤其是各种形式的循环（`for`, `while`, `do-while`）和方法调用。

因此，常见的安全点有：方法调用结束、循环的末尾、异常跳转、其他可以暂停程序的地方等。

### 2.2 线程停滞

如何在垃圾收集发生时让所有线程都跑到最近的安全点，然后停顿下来？

这里有两种方案可以选择：抢先式中断 和 主动式中断：

- **抢先式中断**：不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程响应 GC 事件。
- **主动式中断**：的思路是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起。轮询标志的地方除了安全点以外，还要加上所有创建对象和其他需要在 Java 堆上分配内存的地方，这是为了检查是否即将要发生垃圾收集，避免没有足够内存分配新对象。
## 3 安全区域

安全区域（Safe Region）的引入主要是为了解决线程在 **无法主动检查安全点** 的情况下，如何确保 GC（垃圾回收）能安全地执行的问题，

在这么几种情况下，线程无法主动执行到达安全点：

- 线程被阻塞的情况，比如进行线程 IO 操作或者等待锁。
- 线程处于非活动状态，比如 WAITING 或者 BLOCKED 状态。

安全区域是指能够确保在某一段代码片段之中，**引用关系** 不会发生变化，因此，在安全区域中任意地方开始垃圾收集都是安全的；我们也可以把安全区域看作被扩展拉伸了的安全点。

在GC 期间，如果线程是非活跃的，它们无法主动到达安全点。此时，线程声明自己处于 **安全区域**，GC 可以顺利进行。

当这些线程被唤醒时，安全区域的边界会确保线程在执行期间不会改变引用，线程会在边界处被暂停，直到 GC 完成。这保证了在 GC 过程中，线程的引用不会被不一致地修改，同时也避免了线程需要主动等待进入安全点的问题。
### 1 加密算法介绍
加密算法是一种用数学方法对数据进行变换的技术，目的是保护数据的安全，防止被未经授权的人读取或修改。加密算法可以分为三大类：对称加密算法、非对称加密算法和哈希算法（也叫摘要算法）。
日常开发中常见的需要用到加密算法的场景：
1. 保存在数据库中的密码需要加盐之后使用哈希算法（比如 BCrypt）进行加密。
2. 保存在数据库中的银行卡号、身份号这类敏感数据需要使用对称加密算法（比如 AES）保存。
3. 网络传输的敏感数据比如银行卡号、身份号需要用 HTTPS + 非对称加密算法（如 RSA）来保证传输数据的安全性。
严格上来说，哈希算法其实不属于加密算法，只是可以用到某些加密场景中（例如密码加密），两者可以看作是并列关系。加密算法通常指的是可以将明文转换为密文，并且能够通过某种方式（如密钥）再将密文还原为明文的算法。而哈希算法是一种单向过程，它将输入信息转换成一个固定长度的、看似随机的哈希值，但这个过程是不可逆的，也就是说，不能从哈希值还原出原始信息。
### 2 哈希算法
#### 2.1 哈希算法介绍
哈希算法也叫散列函数或摘要算法，它的作用是对任意长度的数据生成一个固定长度的唯一标识，也叫哈希值、散列值或消息摘要，哈希算法的是不可逆的，无法通过哈希之后的值再得到原值，它的作用是可以用来验证数据的完整性和一致性。
一个安全的散列算法需要满足如下两个条件，也是散列算法的两个特性。 
1. **抗碰撞**：根据一个输入，找到一个其它输入得到相同的输出，在计算上是不可行的； 
2. **不可逆性**：根据一个输出，找到一个输入其散列值等于输出，在计算上是不可行的，即不可能从结果逆向推导初始值。
哈希算法可以简单分为两类：
3. **加密哈希算法**：安全性较高的哈希算法，它可以提供一定的数据完整性保护和数据防篡改能力，能够抵御一定的攻击手段，安全性相对较高，但性能较差，适用于对安全性要求较高的场景。例如 SHA2、SHA3、SM3、RIPEMD-160、BLAKE2、SipHash 等等。
4. **非加密哈希算法**：安全性相对较低的哈希算法，易受到暴力破解、冲突攻击等攻击手段的影响，但性能较高，适用于对安全性没有要求的业务场景。例如 CRC32、MurMurHash3、SipHash 等等。
除了这两种之外，还有一些特殊的哈希算法，例如安全性更高的**慢哈希算法**。
#### 2.1 MD 系列算法
MD 算法有多个版本，包括 MD2、MD4、MD5 等，其中 MD5 是最常用的版本，它可以生成一个 128 位（16 字节）的哈希值。除了这些版本，还有一些基于 MD4 或 MD5 改进的算法，如 RIPEMD、HAVAL 等。
即使是最安全 MD 算法 MD5 也存在被破解的风险，攻击者可以通过暴力破解或彩虹表攻击等方式，找到与原始数据相同的哈希值，从而破解数据，为了增加破解难度，通常可以选择加盐，指通过在密码任意固定位置插入特定的字符串，让哈希后的结果和使用原始密码的哈希结果不相符，这种过程称之为 “加盐”。
加盐之后就安全了吗？并不一定，这只是增加了破解难度，不代表无法破解。而且，MD5 算法本身就存在弱碰撞（Collision）问题，即多个不同的输入产生相同的 MD5 值，因此，MD 算法已经不被推荐使用，建议使用更安全的哈希算法比如 SHA-2、Bcrypt。
```java
// 创建MD5摘要对象
MessageDigest messageDigest = MessageDigest.getInstance("MD5");
messageDigest.update(originalString.getBytes(StandardCharsets.UTF_8));
// 计算哈希值
byte[] result = messageDigest.digest();
// 将哈希值转换为十六进制字符串
String hexString = new HexBinaryAdapter().marshal(result);
System.out.println("Original String: " + originalString);
System.out.println("MD5 Hash: " + hexString.toLowerCase());
```
#### 2.2 SHA 系列算法
SHA（Secure Hash Algorithm）系列算法是一组密码哈希算法，用于将任意长度的数据映射为固定长度的哈希值，SHA 系列算法由美国国家安全局于 1993 年设计，目前共有 SHA-1、SHA-2、SHA-3 三种版本。
##### 2.2.1 SHA-1 算法
SHA-1 算法将任意长度的数据映射为 160 位的哈希值。然而，**SHA-1 算法存在一些严重的缺陷**，比如安全性低，容易受到碰撞攻击和长度扩展攻击。因此，SHA-1 算法已经不再被推荐使用。 SHA-2 家族（如 SHA-256、SHA-384、SHA-512 等）和 SHA-3 系列是 SHA-1 算法的替代方案，它们都提供了更高的安全性和更长的哈希值长度。
##### 2.2.2 SHA-2 家族
SHA-2 家族是在 SHA-1 算法的基础上改进而来的，采用了更复杂的运算过程和更多的轮次，使得攻击者更难以通过预计算或巧合找到碰撞。
相比 MD5 算法，SHA-2 算法之所以更强，主要有两个原因：
- **哈希值长度更长**：例如 SHA-256 算法的哈希值长度为 256 位，而 MD5 算法的哈希值长度为 128 位，这就提高了攻击者暴力破解或者彩虹表攻击的难度。
- **更强的碰撞抗性**：SHA 算法采用了更复杂的运算过程和更多的轮次，使得攻击者更难以通过预计算或巧合找到碰撞。目前还没有找到任何两个不同的数据，它们的 SHA-256 哈希值相同。
当然，SHA-2 也不是绝对安全的，也有被暴力破解或者彩虹表攻击的风险，所以，在实际的应用中，加盐还是必不可少的。
##### 2.2.3 SHA-3 算法
为了寻找一种更安全和更先进的密码哈希算法，美国国家标准与技术研究院在 2007 年公开征集 SHA-3 的候选算法。NIST 一共收到了 64 个算法方案，经过多轮的评估和筛选，最终在 2012 年宣布 Keccak 算法胜出，成为 SHA-3 的标准算法。
Keccak 算法具有与 MD 和 SHA-1/2 完全不同的设计思路，即海绵结构（Sponge Construction），使得传统攻击方法无法直接应用于 SHA-3 的攻击中，能够抵抗目前已知的所有攻击方式包括碰撞攻击、长度扩展攻击、差分攻击等。
由于 SHA-2 算法还没有出现重大的安全漏洞，而且在软件中的效率更高，所以大多数人还是倾向于使用 SHA-2 算法。
#### 2.3 Bcrpt 算法
Bcrypt 算法是一种基于 Blowfish 加密算法的密码哈希算法，专门为密码加密而设计，安全性高。
由于 Bcrypt 采用了 salt（盐） 和 cost（成本） 两种机制，它可以有效地防止彩虹表攻击和暴力破解攻击，从而保证密码的安全性。salt 是一个随机生成的字符串，用于和密码混合，增加密码的复杂度和唯一性。cost 是一个数值参数，用于控制 Bcrypt 算法的迭代次数，增加密码哈希的计算时间和资源消耗。
Bcrypt 算法可以根据实际情况进行调整加密的复杂度，可以设置不同的 cost 值和 salt 值，从而满足不同的安全需求，灵活性很高。
Java 应用程序的安全框架 Spring Security 支持多种密码编码器，其中 `BCryptPasswordEncoder` 是官方推荐的一种，它使用 BCrypt 算法对用户的密码进行加密存储。
### 3 对称加密
对称加密算法是指加密和解密使用的是同一种密钥的算法，也叫共享密钥加密算法，常见的对称加密算法有 DES、3DES、AES 等。
#### 3.1 DES 算法
DES（Data Encryption Standard）使用 64 位的密钥(有效秘钥长度为 56 位,8 位奇偶校验位)和 64 位的明文进行加密。
虽然 DES 一次只能加密 64 位，但我们只需要把明文划分成 64 位一组的块，就可以实现任意长度明文的加密，如果明文长度不是 64 位的倍数，必须进行填充，常用的模式有 `PKCS5Padding`, `PKCS7Padding`, `NOPADDING`。
DES 加密算法的基本思想是将 64 位的明文分成两半，然后对每一半进行多轮的变换，最后再合并成 64 位的密文。这些变换包括置换、异或、选择、移位等操作，每一轮都使用了一个子密钥，而这些子密钥都是由同一个 56 位的主密钥生成的；DES 加密算法总共进行了 16 轮变换，最后再进行一次逆置换，得到最终的密文。
这是一个经典的对称加密算法，但也有明显的缺陷，即 56 位的密钥安全性不足，已被证实可以在短时间内破解，为了提高 DES 算法的安全性，人们提出了一些变种或者替代方案，例如 3DES（Triple DES）。
#### 3.2 3DES 算法
3DES（Triple DES）是 DES 向 AES 过渡的加密算法，它使用 2 个或者 3 个 56 位的密钥对数据进行三次加密，相当于是对每个数据块应用三次 DES 的对称加密算法。
为了兼容普通的 DES，3DES 并没有直接使用 加密->加密->加密 的方式，而是采用了加密->解密->加密 的方式。当三种密钥均相同时，前两步相互抵消，相当于仅实现了一次加密，因此可实现对普通 DES 加密算法的兼容。3DES 更为安全，但处理速度不高。
#### 3.3 AES 算法
AES（Advanced Encryption Standard）算法是一种更先进的对称密钥加密算法，它使用 128 位、192 位或 256 位的密钥对数据进行加密或解密，密钥越长，安全性越高。
AES 也是一种分组密码，分组长度只能是 128 位，也就是说，每个分组为 16 个字节，AES 加密算法有多种工作模式，如：ECB、CBC、OFB、CFB、CTR、XTS、OCB、**GCM**，不同的模式参数和加密流程不同，但是核心仍然是 AES 算法。
和 DES 类似，对于不是 128 位倍数的明文需要进行填充，常用的填充模式有 PKCS5Padding, PKCS7Padding, NOPADDING，不过，AES-GCM 是流加密算法，可以对任意长度的明文进行加密，所以对应的填充模式为 NoPadding，即无需填充，AES 的速度比 3DES 快，而且更安全。
![[DES vs AES.png|center|700]]
Java 使用 AES 算法案例: https://github.com/RyanYuan-commits/play_ground/blob/main/encryption/src/main/java/org/ryan/AESExample.java
### 4 非对称加密
非对称加密算法是指加密和解密使用不同的密钥的算法，也叫公开密钥加密算法。
这两个密钥互不相同，一个称为公钥，另一个称为私钥，公钥可以公开给任何人使用，私钥则要保密；如果用公钥加密数据，只能用对应的私钥解密；如果用私钥加密数据，只能用对应的公钥解密，这样就可以实现数据的安全传输和身份认证。
常见的非对称加密算法有 RSA、DSA、ECC 等。
#### 4.1 RSA 算法
RSA（Rivest–Shamir–Adleman algorithm）算法是一种基于大数分解的困难性的非对称加密算法，它需要选择两个大素数作为私钥的一部分，然后计算出它们的乘积作为公钥的一部分（寻求两个大素数比较简单，而将它们的乘积进行因式分解却极其困难）。
RSA 算法的安全性依赖于大数分解的难度，目前 512 位和 768 位的 RSA 公钥被成功分解，建议使用 2048 位或以上的密钥长度。
它的优点是简单易用，可以用于数据加密和数字签名；缺点是运算速度慢，不适合大量数据的加密，RSA 算法是是目前应用最广泛的非对称加密算法，像 SSL/TLS、SSH 等协议中就用到了 RSA 算法。
=> [[🍭【网络】HTTPS 详解]]
Java 使用 RSA 案例： https://github.com/RyanYuan-commits/play_ground/blob/main/encryption/src/main/java/org/ryan/RSAExample.java
#### 4.2 DSA 算法
DSA（Digital Signature Algorithm）算法是一种基于离散对数的困难性的非对称加密算法，它需要选择一个素数 q 和一个 q 的倍数 p 作为私钥的一部分，然后计算出一个模 p 的原根 g 和一个模 q 的整数 y 作为公钥的一部分。DSA 算法的安全性依赖于离散对数的难度，目前已经有 1024 位的 DSA 公钥被成功破解，因此建议使用 2048 位或以上的密钥长度。
DSA 算法的优点是数字签名速度快，适合生成数字证书；缺点是不能用于数据加密，且签名过程需要随机数。
DSA 算法签名过程：
1. 使用消息摘要算法对要发送的数据进行加密，生成一个信息摘要，也就是一个短的、唯一的、不可逆的数据表示。
2. 发送方用自己的 DSA 私钥对信息摘要再进行加密，形成一个数字签名，也就是一个可以证明数据来源和完整性的数据附加。
3. 将原始数据和数字签名一起通过互联网传送给接收方。
4. 接收方用发送方的公钥对数字签名进行解密，得到信息摘要。同时，接收方也用消息摘要算法对收到的原始数据进行加密，得到另一个信息摘要。接收方将两个信息摘要进行比较，如果两者一致，则说明在传送过程中数据没有被篡改或损坏；否则，则说明数据已经失去了安全性和保密性。
![[DSA 算法.png|center|1000]]
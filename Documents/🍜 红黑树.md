普通二叉搜索树的致命缺点，时间复杂度趋近于 O(n)。
![[普通二叉搜索树的致命缺点.png|500]]


---

红黑树的前身——4 阶 B 树：
属于多叉树，每个节点最多有三个数据项和四个子节点，根据子节点数目的不同，其节点分为三类，也就是二节点、三节点和子节点。
![[4 阶 B 树的2、3、4 节点.png|1000]]
4 阶 B 树插入 1～ 10
![[4 阶 B 树插入 1～ 10.png|1500]]

---

红黑树的特点：
- 每个节点要么是红色，要么是黑色
- 根节点永远是黑色的
- 所有叶子节点都是黑色的
- 每个红色节点的两个子节点一定都是黑色的
- 从任一节点到其子树中对每个叶子节点的路径都包含相同数量的黑色节点
根据红黑树的特点，判断下面的树形结构是否是一个红黑树：
![[判断下面的结构是否是一个红黑树.png|500]]
上面的树形结构并不是一个红黑树，因为除了记录数据的节点以外，还额外的有隐式的黑色叶子节点，全部绘制出来是这样的：
![[判断下面的结构是否是一个红黑树2.png|800]]
15 -> 8 -> 叶子节点 这一路径只经过了三个黑色节点，可以判断上面的树形结构并不是一个红黑树。

---

![[4 阶 B 树是红黑树的前身.png|1300]]
前面提到，4 阶 B 树是红黑树的前身，观察上面的图，将红色节点全部上移到其父节点的位置就可以看到它们的联系非常明显；具体来说，体现在这些地方：
- 红黑树的黑色节点的个数 = 4 阶 B 树的节点个数
- 4 阶 B 树的每一个节点中，黑色节点为父节点，红色节点为子节点（黑色中间，红色两边）
所以，对于红黑树的插入操作，都可以转化为对于 4 阶 B 树的插入操作来理解，然后按照上面的关系转化回红黑树即可。

---

左旋和右旋操作：
![[左旋和右旋操作.png|800]]
右旋操作，是将左边的节点变成根节点，其效果就是将 Y 的右节点与 X 的左节点做一下交换，此时 Y 就变为了根节点。
左旋操作，就是将右边的节点变为根节点，其效果就是将 X 的左节点与 Y 的右节点做一下交换。
在代码实现上，右旋操作就是将 Y 的右指针指向 X，然后将 X 的左节点指向 Y 的右节点；左旋操作就是将 X 的左指针指向 Y，然后将 Y 的右节点指向 X 的左节点。

---

红黑树的插入操作：
如果插入的节点是根节点，则其一定为黑色，其余插入的节点最开始一定为红色。
因为如果插入的节点是黑色节点的话，为了维持红黑树的 “从任一节点到其子树中对每个叶子节点的路径都包含相同数量的黑色节点“ 特点，会产生很多冲突，而如果插入的是红色节点的话，就是可能出现连续的两个红色节点，这时候只需要进行旋转和变色来进行调整。

红黑树的插入情况可以分为十二种情况，其中，父节点为黑色的四种情况可以不需要做任何处理，直接插入：
![[红黑树的插入父节点为黑色的四种情况.png|900]]
也就是上图蓝色节点的四种情况，此时直接插入红色节点不需要做任何处理，因为不会影响到红黑树的性质。

而对于插入节点的父节点是红色节点的情况就需要分类讨论一下了，先来看几种不需要上溢的情况，也就是相当于对 4 阶 B 树的 2 节点执行插入操作：
![[插入节点的父节点是红色节点且无需上移的情况.png|800]]
我们以插入节点的父节点和其父节点以及子节点的关系，将其命名为 RL、RR、LL 和 LR 四种情况。
先观察 RR 的情况，此时如果是正常的 4 阶 B 树的话，只需要将 13 放到 12 节点的后面即可，但是对于红黑树 “每个红色节点的两个子节点一定都是黑色的“ 的特征，是不允许两个红色节点连续出现的；
而上面我们提到，红黑树的黑色节点的个数 = 4 阶 B 树的节点个数，在这几种不需要上溢的情况，不会产生新的 4 阶 B 树的节点，所以我们无法增加新的黑色节点，而是需要转移，在上面 RR 的情况，只需要将 10 节点变为红色，12 节点变为黑色即可此时的情况是这样的：
![[RR 插入中间情况.png|300]]
我们要让 12 变为新的根节点，就要进行左旋的操作，也就是将 12 的左指针指向 10，然后将 10 指向 12 的左子树（上图没有画出，但应该是空的黑色节点），然后将 8 的右指针指向 12 即可。
同理可得，LL 的情况中，将 18 变色为黑色，20 变色为红色，然后进行一次右旋的操作即可。

再来看 RL 的情况，对比 4 阶 B 树，此时 11 应该插入到 10 和 12 中间，也就是最终想要的结果是这样的：
![[RL 插入的中间情况.png|700]]
想要从左边的情况变为右边的情况，就需要执行两次旋转操作，具体来说就是先将 11 变为 12 的根节点，这是一次右旋操作，然后将 11 变为 10 和 12 的根节点，是一次左旋操作，也就是对于这种情况，需要先执行一次右旋操作再执行一次左旋操作。
同理，对于 LR 的情况，就是先执行一次左旋操作，再执行一次右旋操作。

然后来看四种需要上溢的情况：
![[四种需要上溢的情况.png|800]]
这几种情况，只需要变色，不需要做其他的旋转处理，比如插入 1 的情况：
![[四种需要上溢的情况1.png|800]]
对于这种插入第四个节点的情况表，我们需要先将 4 节点上溢，但是这是红黑树，上溢相当于没有做任何操作，此时对于 4 阶 B 树来说，产生了两个新的节点，所以 2 和 6 节点需要被染成黑色；
此时上溢的 4 节点，染成红色，作为一个节点插入到 8 节点，此时有需要对 15 执行上溢操作
最终的效果就是这样的
![[四种需要上溢的情况2.png|800]]
可以看到，指针完全没有变化，只是颜色发生了改变。

---

红黑树的删除操作

---

红黑树具有平衡性，最差的情况下查找的时间复杂度为 O(logn)，而普通的二叉搜索树在可能会退化为链表，普通二叉搜索树的最坏情况为 O(n)。
而相较于平衡二叉树是一种严格平衡的二叉树，维护平衡地方代价更高，因为它需要更多的旋转操作来确保平衡，相对而言，红黑树在保持平衡的方面效率更高，因此插入和删除操作效率更好。

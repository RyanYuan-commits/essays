Serial 收集器是最基础、历史最悠久的收集器，曾经(在JDK 1.3.1之前)是 HotSpot 虚拟机新生代收集器的唯一选择。
Serial 收集器使用的是标记复制算法来进行年轻代的垃圾收集，以及 ==标记-整理算法== 来进行老年代的垃圾收集。

Serial 收集器是一个 **单线程工作** 的收集器，但 “单线程” 的意义并不仅仅是说明它只会使用一个处理器或一条收集线程去完成垃圾收集工作，更重要的是强调在它进行垃圾收集时，必须暂停其他所有工作线程，直到它收集结束。
![[Serial、Serial Old 收集器运行示意图.png]]

“Stop The World”这个词语也许听起来很酷，但这项工作是由虚拟机在后台自动发起和自动完成的，在用户不可知、不可控的情况 下把用户的正常工作的线程全部停掉，这对很多应用来说都是不能接受的。读者不妨试想一下，要是你的电脑每运行一个小时就会暂停响应五分钟，你会有什么样的心情?

从 JDK 1.3 开始，一直到现在最新的 JDK13，HotSpot 虚拟机开发团队为消除或者降低用户线程因垃圾收集而导致停顿的努力一直持续进行着，从Serial收集器到 Parallel 收集器，再到 Concurrent Mark Sweep(CMS)和 Garbage First(G1) 收集器，最终至现在垃圾收集器的最前沿成果 Shenandoah 和 ZGC 等，我们看到了一个个越来越构思精巧，越来越优秀，也越来越复杂的垃圾收集器不断涌现，用户线程的停顿时间在持续缩短，但是仍然没有办法彻底消除(这里不去讨论RTSJ中的收集器)，探索更优秀垃圾收集器的工作仍在继续。

写到这里，笔者似乎已经把 Serial 收集器描述成一个最早出现，但目前已经老而无用，食之无味， 弃之可惜的“鸡肋”了。

但事实上，迄今为止，它依然是 ==HotSpot 虚拟机运行在客户端模式下的默认新生代收集器==；它对比其他收集器更加的简单而高效(与其他收集器的单线程相比)，对于内存资源受限的环境，它是所有收集器里额外内存消耗最小的；对于单核处理器或处理器核心数较少的环境来说，Serial 收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得最高的单线程收集效率。
在用户桌面的应用场景以及近年来流行的部分微服务应用中，分配给虚拟机管理的内存一般来说并不会特别大，收集几十兆甚至一两百兆的新生代，垃圾收集的停顿时间完全可以控制在十几、几十毫秒，最多一百多毫秒以内，只要不是频繁发生收集，这点停顿时间对许多用户来说是完全可以接受的。**Serial 收集器对于运行在客户端模式下的虚拟机来说是一个很好的选择。**

Serial 收集器的老年代版本 Serial Old 在服务端模式下，它也可能有两种用途：
1. 一种是在 JDK 5 以及之前的版本中与 Parallel Scavenge 收集器搭配使用
2. 另外一种就是作为 CMS 收集器发生失败时的后备预案，在并发收集发生 ConcurrentModeFailure 时使用。

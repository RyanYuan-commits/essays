## 1 如何判断对象存活？

### 1.1 引用计数算法

引用计数算法判断对象死亡的方式：在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可能再被使用的。

但是在 Java 领域，很少有通过引用计数的方式来管理内存的，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如**单纯的引用计数就很难解决对象之间相互循环引用的问题**。
### 1.2 可达性分析算法

当前主流的商用程序语言的内存管理子系统，都是通过 **可达性分析（Reachability Analysis）算法**来判定对象是否存活的。

可达性分析算法的核心思想是：通过一系列被称为 “GC Roots” 的对象作为起始点，从这些起始点向下搜索（遍历对象引用链）。当一个对象到 GC Roots 之间没有任何引用链相连时，则证明此对象是不可用的，可以被回收。

在 Java 技术体系中，可以作为 GC Roots 的 **对象** 包括以下几种：

- **虚拟机栈（栈帧中的局部变量表）中引用的对象**：比如，一个方法中定义的局部变量，它引用了一个对象。只要方法还在执行，这个局部变量就有效，它引用的对象就是可达的；
- **本地方法栈中 JNI 引用的对象**：如果 Java 代码调用了本地方法（C/C++ 代码），并且本地方法中创建或引用了 Java 对象，这些对象也会被视为 GC Roots；
- **方法区中静态属性或常量引用的对象**：比如，`public static (final) Object instance;`，只要类被加载，这个静态变量引用的对象就是可达的；
- **所有被同步锁（`synchronized` 关键字）持有的对象**：正在被某个线程持有的锁对象，也算是 GC Roots；
- **JVM 内部的引用**：比如，基本数据类型对应的 Class 对象、一些常驻的异常对象（`NullPointerException`、`OutOfMemoryError`）、系统类加载器等；
- 反映 JVM 内部状态的 JNI Handles 和 JNI Global References。

## 2 并发的可达性分析

### 2.1 并发的必要性

当前主流编程语言的垃圾收集器基本上都是依靠可达性分析算法来判定对象是否存活的，可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析，这意味着必须全程冻结用户线程的运行。

在根节点枚举这个步骤中，由于 GC Roots 相比起整个 Java 堆中全部的对象毕竟还算是极少数，且在各种优化技巧(如 OopMap)的加持下，它带来的停顿已经是非常短暂且相对固定（不随堆容量而增长）的了。

=> [[🥝【Java】根节点枚举]]

可从 GC Roots 再继续往下遍历对象图，这一步骤的停顿时间就必定会与 Java 堆容量直接成正比例关系了，堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长，这听起来是理所当然的事情。

要知道包含“ 标记”阶段是所有追踪式垃圾收集算法的共同特征，如果这个阶段会随着堆变大而等比例增加停顿时间，其影响就会波及几乎所有的垃圾收集器，同理可知，如果能够削减这部分停顿时间的话，那收益也将会是系统性的。

### 2.2 三色标记法

#### 基本思想

想解决或者降低用户线程的停顿，就要先搞清楚为什么必须在一个能保障一致性的快照上才能进行对象图的遍历？为了能解释清楚这个问题，我们引入三色标记作为工具来辅助推导，把遍历对象图过程中遇到的对象，按照 “是否访问过” 这个条件标记成以下三种颜色: 

- ==白色==：表示对象尚未被垃圾收集器访问过。显然在可达性分析刚刚开始的阶段，所有的对象都是白色的，若在分析结束的阶段，仍然是白色的对象，即代表不可达。
- ==黑色==：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都已经扫描过。黑色的对象代表已经扫描过，它是安全存活的，如果有其他对象引用指向了黑色对象，无须重新扫描一遍。黑色对象不可能直接(不经过灰色对象)指向某个白色对象。
- ==灰色==：表示对象已经被垃圾收集器访问过，但这个对象上至少存在一个引用还没有被扫描过。

关于可达性分析的扫描过程，读者不妨发挥一下想象力，把它看作对象图上一股以灰色为波峰的波纹从黑向白推进的过程：

![[三色标记法流程图.png]]

如果用户线程此时是冻结的，只有收集器线程在工作，那不会有任何问题。但如果用户线程与收集器是在分析的同时并发工作呢？

#### 并发问题分析

收集器在对象图上标记颜色，同时用户线程在修改引用关系——即修改对象图的结构，这样可能出现两种后果。

1. 一种是把原本消亡的对象错误标记为存活， 这不是好事，但其实是可以容忍的，只不过产生了一点逃过本次收集的浮动垃圾而已，下次收集清理掉就好。
2. 另一种是把原本存活的对象错误标记为已消亡，这就是非常致命的后果了，程序肯定会因此发生错误。

Wilson 于 1994 年在理论上证明了，当且仅当以下两个条件同时满足时，会产生这种 “对象消失” 的问题，即原本应该是黑色的对象被误标为白色:
- 赋值器插入了一条或多条从黑色对象到白色对象的新引用;
- 赋值器删除了全部从灰色对象到该白色对象的直接或间接引用

也就是从未扫描的节点已经无法到达此节点，且引用此节点的节点之后也不会被再次扫描，在这种情况下，出现 “对象消失” 的问题就是必然的。

#### 解决方案

因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别产生了两种解决方案：增量更新(Incremental Update)和原始快照(Snapshot At The Beginning，SATB)

- **增量更新**感知的是第一个条件，在分析过程中，如果**黑色对象插入新的指向白色对象的引用关系**，就将这个新插入的引用记录下来，等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次。这可以简化理解为，黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。
- **原始快照**感知的是第二个条件，在分析过程中，如果**灰色对象要删除指向白色对象的引用关系**，就将这个白色对象的引用记录下来，在并发扫描结束之后，这些白色对象仍然视为可以到达的，所以需要以白色对象为根，重新扫描一次。（这会产生浮动垃圾的问题，就比如原先这个灰色对象指向白色对象的引用就是应用程序想断开的，但是被使用原始快照算法的垃圾收集器记录了下来，误以为是不该回收的。导致这当前阶段无法回收，只能在下次垃圾回收的时候回收。）这也可以简化理解为，无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索，即使真的需要删除，我也保存下来。

以上无论是对引用关系记录的插入还是删除，虚拟机的记录操作都是通过写屏障实现的。

在 HotSpot 虚拟机中，增量更新和原始快照这两种解决方案都有实际应用，譬如，CMS 是基于增量更新来做并发标记的，G1、Shenandoah 则是用原始快照来实现。